<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#6366f1">
    <meta name="description" content="AI-powered voice flashcard learning platform with spaced repetition">
    <title>VoiceCards - Learn Smarter with AI</title>
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --primary-light: #818cf8;
            --secondary: #ec4899;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --dark: #1f2937;
            --light: #f9fafb;
            --gray: #6b7280;
            --border-radius: 12px;
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--light);
            color: var(--dark);
            min-height: -webkit-fill-available; /* iOS Safari */
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
            padding-bottom: env(safe-area-inset-bottom);
            padding-top: env(safe-area-inset-top);
        }
        
        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: opacity 0.5s ease;
        }
        
        .loading-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-content {
            text-align: center;
            color: white;
        }
        
        .loading-icon {
            width: 80px;
            height: 80px;
            margin: 0 auto 20px;
            position: relative;
        }
        
        .loading-icon::before,
        .loading-icon::after {
            content: '';
            position: absolute;
            border: 3px solid transparent;
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        .loading-icon::before {
            width: 100%;
            height: 100%;
        }
        
        .loading-icon::after {
            width: 60%;
            height: 60%;
            top: 20%;
            left: 20%;
            animation-direction: reverse;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Navigation - Mobile First */
        nav {
            background: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            padding: 12px 16px;
            padding-top: calc(12px + env(safe-area-inset-top));
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo {
            font-size: 20px;
            font-weight: bold;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .nav-menu {
            display: none; /* Hidden on mobile */
        }
        
        .nav-item {
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: var(--transition);
            font-size: 14px;
            font-weight: 500;
            min-height: 44px; /* Touch target */
            display: flex;
            align-items: center;
        }
        
        .nav-item:hover {
            background: var(--light);
        }
        
        .nav-item.active {
            background: var(--primary);
            color: white;
        }
        
        /* Bottom Navigation Bar (Mobile) */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            border-top: 1px solid #e5e7eb;
            padding: 8px 0;
            padding-bottom: calc(8px + env(safe-area-inset-bottom));
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 100;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .bottom-nav-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px;
            cursor: pointer;
            transition: var(--transition);
            min-height: 56px; /* Touch target */
            color: var(--gray);
            font-size: 12px;
        }
        
        .bottom-nav-item.active {
            color: var(--primary);
        }
        
        .bottom-nav-item span {
            font-size: 20px;
            margin-bottom: 4px;
        }
        
        .bottom-nav-item:hover {
            background: var(--light);
        }
        
        /* Main Container - Mobile First */
        .app-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 16px;
            padding-bottom: calc(80px + env(safe-area-inset-bottom)); /* Space for bottom nav */
            display: none;
        }
        
        .app-container.active {
            display: block;
        }
        
        /* Onboarding */
        .onboarding-container {
            max-width: 600px;
            margin: 60px auto;
            text-align: center;
        }
        
        .onboarding-step {
            display: none;
            animation: fadeIn 0.5s ease;
        }
        
        .onboarding-step.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .onboarding-title {
            font-size: 36px;
            margin-bottom: 20px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .onboarding-description {
            font-size: 18px;
            color: var(--gray);
            margin-bottom: 40px;
            line-height: 1.6;
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 40px 0;
        }
        
        .feature-card {
            background: white;
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            cursor: pointer;
            transition: var(--transition);
            border: 2px solid transparent;
        }
        
        .feature-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }
        
        .feature-card.selected {
            border-color: var(--primary);
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
        }
        
        .feature-icon {
            font-size: 36px;
            margin-bottom: 10px;
        }
        
        /* Dashboard */
        .dashboard-grid {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        @media (max-width: 768px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* Sidebar */
        .sidebar {
            background: white;
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            height: fit-content;
        }
        
        .user-profile {
            text-align: center;
            padding-bottom: 20px;
            border-bottom: 1px solid #e5e7eb;
            margin-bottom: 20px;
        }
        
        .user-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            color: white;
            margin: 0 auto 10px;
        }
        
        .user-name {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .user-level {
            font-size: 14px;
            color: var(--gray);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: var(--light);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary);
        }
        
        .stat-label {
            font-size: 12px;
            color: var(--gray);
            margin-top: 5px;
        }
        
        .deck-list {
            margin-top: 20px;
        }
        
        .deck-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            margin-bottom: 10px;
            background: var(--light);
            border-radius: 8px;
            cursor: pointer;
            transition: var(--transition);
        }
        
        .deck-item:hover {
            background: var(--primary);
            color: white;
            transform: translateX(5px);
        }
        
        .deck-name {
            font-weight: 500;
        }
        
        .deck-count {
            font-size: 12px;
            background: white;
            color: var(--primary);
            padding: 2px 8px;
            border-radius: 12px;
        }
        
        /* Main Content Area */
        .main-content {
            background: white;
            border-radius: var(--border-radius);
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            min-height: 600px;
        }
        
        /* Study Session */
        .study-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--light);
        }
        
        .session-info {
            display: flex;
            gap: 30px;
        }
        
        .session-stat {
            display: flex;
            flex-direction: column;
        }
        
        .session-stat-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary);
        }
        
        .session-stat-label {
            font-size: 12px;
            color: var(--gray);
        }
        
        .progress-bar {
            width: 200px;
            height: 8px;
            background: var(--light);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary) 0%, var(--secondary) 100%);
            transition: width 0.5s ease;
        }
        
        /* Card Display - Mobile First */
        .card-container {
            max-width: 100%;
            margin: 0 auto;
            padding: 0;
        }
        
        .card-3d {
            perspective: 1000px;
            margin-bottom: 24px;
        }
        
        .card-inner {
            position: relative;
            width: 100%;
            min-height: 50vh; /* Mobile: take up half screen */
            min-height: calc(50vh - 120px); /* Account for nav and controls */
            transition: transform 0.6s;
            transform-style: preserve-3d;
            touch-action: pan-y; /* Allow vertical scroll */
        }
        
        .card-inner.flipped {
            transform: rotateY(180deg);
        }
        
        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            min-height: 50vh;
            backface-visibility: hidden;
            border-radius: 16px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 32px 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            cursor: pointer;
        }
        
        .card-front {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
        }
        
        .card-back {
            background: white;
            transform: rotateY(180deg);
            border: 2px solid var(--primary);
        }
        
        .card-text {
            font-size: 28px; /* Mobile: larger text */
            font-weight: bold;
            text-align: center;
            margin-bottom: 16px;
            line-height: 1.4;
            word-wrap: break-word;
            max-width: 100%;
        }
        
        .card-subtext {
            font-size: 16px;
            opacity: 0.9;
            text-align: center;
            line-height: 1.5;
        }
        
        .card-back .card-text {
            color: var(--dark);
        }
        
        .card-back .card-subtext {
            color: var(--gray);
        }
        
        /* Voice Visualization */
        .voice-visualizer {
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            margin: 30px 0;
        }
        
        .voice-bar {
            width: 4px;
            background: var(--primary);
            border-radius: 2px;
            transition: height 0.1s ease;
        }
        
        .voice-visualizer.active .voice-bar {
            animation: wave 0.8s ease-in-out infinite;
        }
        
        .voice-visualizer.active .voice-bar:nth-child(2) { animation-delay: 0.1s; }
        .voice-visualizer.active .voice-bar:nth-child(3) { animation-delay: 0.2s; }
        .voice-visualizer.active .voice-bar:nth-child(4) { animation-delay: 0.3s; }
        .voice-visualizer.active .voice-bar:nth-child(5) { animation-delay: 0.4s; }
        
        @keyframes wave {
            0%, 100% { height: 20px; }
            50% { height: 60px; }
        }
        
        /* Control Panel - Mobile First */
        .control-panel {
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* Mobile: 3 columns */
            gap: 12px;
            margin-top: 24px;
            padding-bottom: 8px;
        }
        
        .control-btn {
            padding: 16px 12px;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 6px;
            min-height: 80px; /* Larger touch target */
            touch-action: manipulation; /* Remove double-tap zoom */
        }
        
        .control-btn:active {
            transform: scale(0.95);
        }
        
        .control-btn span {
            font-size: 24px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
        }
        
        .btn-success {
            background: var(--success);
            color: white;
        }
        
        .btn-warning {
            background: var(--warning);
            color: white;
        }
        
        .btn-danger {
            background: var(--danger);
            color: white;
        }
        
        .btn-secondary {
            background: var(--light);
            color: var(--dark);
        }
        
        .btn-voice {
            background: linear-gradient(135deg, var(--secondary) 0%, var(--primary) 100%);
            color: white;
            position: relative;
            overflow: hidden;
        }
        
        .btn-voice.listening::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: pulse 1s ease-out infinite;
        }
        
        @keyframes pulse {
            to {
                width: 100%;
                height: 100%;
                opacity: 0;
            }
        }
        
        /* Analytics Dashboard */
        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .metric-card {
            background: var(--light);
            padding: 20px;
            border-radius: var(--border-radius);
            border-left: 4px solid var(--primary);
        }
        
        .metric-title {
            font-size: 14px;
            color: var(--gray);
            margin-bottom: 10px;
        }
        
        .metric-value {
            font-size: 32px;
            font-weight: bold;
            color: var(--dark);
            margin-bottom: 10px;
        }
        
        .metric-change {
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .metric-change.positive {
            color: var(--success);
        }
        
        .metric-change.negative {
            color: var(--danger);
        }
        
        /* Chart Container */
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: var(--border-radius);
            margin-top: 20px;
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .chart-title {
            font-size: 18px;
            font-weight: 600;
        }
        
        .chart-filters {
            display: flex;
            gap: 10px;
        }
        
        .filter-btn {
            padding: 6px 12px;
            border: 1px solid var(--light);
            border-radius: 6px;
            background: white;
            font-size: 14px;
            cursor: pointer;
            transition: var(--transition);
        }
        
        .filter-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        
        .chart {
            height: 300px;
            display: flex;
            align-items: flex-end;
            justify-content: space-around;
            padding: 20px 0;
        }
        
        .chart-bar {
            width: 30px;
            background: linear-gradient(to top, var(--primary), var(--primary-light));
            border-radius: 4px 4px 0 0;
            transition: height 0.5s ease;
            position: relative;
        }
        
        .chart-bar:hover {
            opacity: 0.8;
        }
        
        .chart-label {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: var(--gray);
        }
        
        /* Settings Panel */
        .settings-panel {
            display: grid;
            gap: 20px;
        }
        
        .setting-group {
            background: var(--light);
            padding: 20px;
            border-radius: var(--border-radius);
        }
        
        .setting-group-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--dark);
        }
        
        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .setting-item:last-child {
            border-bottom: none;
        }
        
        .setting-info {
            flex: 1;
        }
        
        .setting-label {
            font-weight: 500;
            margin-bottom: 5px;
        }
        
        .setting-description {
            font-size: 14px;
            color: var(--gray);
        }
        
        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.4s;
            border-radius: 26px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: var(--primary);
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
        }
        
        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: var(--border-radius);
            max-width: 500px;
            width: 90%;
            animation: slideUp 0.3s ease;
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .modal-title {
            font-size: 24px;
            font-weight: 600;
        }
        
        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--gray);
        }
        
        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 2000;
        }
        
        .toast {
            background: white;
            padding: 15px 20px;
            border-radius: var(--border-radius);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            animation: slideInRight 0.3s ease;
            min-width: 250px;
        }
        
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .toast.success {
            border-left: 4px solid var(--success);
        }
        
        .toast.error {
            border-left: 4px solid var(--danger);
        }
        
        .toast.info {
            border-left: 4px solid var(--primary);
        }
        
        .toast-icon {
            font-size: 20px;
        }
        
        .toast-message {
            flex: 1;
        }
        
        /* Floating Action Button (Mobile) */
        .fab {
            position: fixed;
            bottom: calc(80px + env(safe-area-inset-bottom));
            right: 20px;
            width: 64px;
            height: 64px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--secondary) 0%, var(--primary) 100%);
            color: white;
            border: none;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            z-index: 99;
            transition: var(--transition);
            touch-action: manipulation;
        }
        
        .fab:active {
            transform: scale(0.9);
        }
        
        .fab.listening {
            animation: pulse-fab 1.5s ease-in-out infinite;
        }
        
        @keyframes pulse-fab {
            0%, 100% {
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            }
            50% {
                box-shadow: 0 4px 30px rgba(99, 102, 241, 0.6);
            }
        }
        
        /* Hands-Free Status (Mobile) */
        .hands-free-status {
            position: fixed;
            top: calc(60px + env(safe-area-inset-top));
            left: 0;
            right: 0;
            background: linear-gradient(135deg, var(--success) 0%, #059669 100%);
            color: white;
            padding: 12px 16px;
            text-align: center;
            font-weight: 600;
            z-index: 99;
            display: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .hands-free-status.active {
            display: block;
        }
        
        /* Voice Visualizer - Mobile Optimized */
        .voice-visualizer {
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
            margin: 20px 0;
        }
        
        .voice-bar {
            width: 3px;
            background: var(--primary);
            border-radius: 2px;
            transition: height 0.1s ease;
            min-height: 8px;
        }
        
        /* Mobile: Hide sidebar, show full-width content */
        .dashboard-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }
        
        .sidebar {
            display: none; /* Hide sidebar on mobile */
        }
        
        .main-content {
            width: 100%;
        }
        
        /* Study header - Mobile optimized */
        .study-header {
            margin-bottom: 20px;
        }
        
        .study-header h2 {
            font-size: 24px;
            margin-bottom: 12px;
        }
        
        .session-info {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .session-stat {
            text-align: center;
            padding: 12px;
            background: var(--light);
            border-radius: 8px;
        }
        
        .session-stat-value {
            display: block;
            font-size: 20px;
            font-weight: bold;
            color: var(--primary);
        }
        
        .session-stat-label {
            display: block;
            font-size: 12px;
            color: var(--gray);
            margin-top: 4px;
        }
        
        /* Responsive Design - Desktop Enhancements */
        @media (min-width: 768px) {
            .bottom-nav {
                display: none; /* Hide bottom nav on desktop */
            }
            
            .nav-menu {
                display: flex; /* Show top nav menu on desktop */
            }
            
            .app-container {
                padding: 24px;
                padding-bottom: 24px; /* No bottom nav padding on desktop */
            }
            
            .dashboard-grid {
                grid-template-columns: 280px 1fr; /* Sidebar + content */
            }
            
            .sidebar {
                display: block; /* Show sidebar on desktop */
            }
            
            .card-inner {
                min-height: 400px; /* Taller cards on desktop */
            }
            
            .card-text {
                font-size: 36px; /* Larger text on desktop */
            }
            
            .control-panel {
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
                gap: 16px;
            }
            
            .control-btn {
                flex-direction: row;
                padding: 16px 24px;
                min-height: 56px;
            }
            
            .control-btn span {
                font-size: 20px;
            }
            
            .fab {
                display: none; /* Hide FAB on desktop */
            }
            
            .hands-free-status {
                display: none !important; /* Hide mobile status bar on desktop */
            }
            
            .logo {
                font-size: 24px;
            }
            
            .study-header h2 {
                font-size: 32px;
            }
        }
        
        @media (min-width: 1024px) {
            .card-text {
                font-size: 42px;
            }
            
            .card-inner {
                min-height: 450px;
            }
        }
        
        /* Offline Indicator */
        .offline-banner {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--warning);
            color: white;
            padding: 10px;
            text-align: center;
            display: none;
            z-index: 3000;
        }
        
        .offline-banner.active {
            display: block;
        }
    </style>
    <!-- Google GenAI SDK - Required for Gemini Live API -->
    <!-- Option 1: Use CDN (if available) -->
    <!-- <script type="module" src="https://cdn.jsdelivr.net/npm/@google/genai@latest/dist/index.js"></script> -->
    <!-- Option 2: For production, bundle @google/genai via npm/webpack/vite -->
    <!-- Option 3: Load SDK dynamically in code (see GeminiLiveAgent.loadSDK) -->
    
    <!-- OpenAI Agents SDK - Required for OpenAI Realtime API -->
    <!-- Install: npm install @openai/agents-realtime -->
    <!-- Or use CDN: <script type="module" src="https://esm.sh/@openai/agents-realtime"></script> -->
    <!-- For production, bundle via npm/webpack/vite -->
    </head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-content">
            <div class="loading-icon"></div>
            <h2>VoiceCards</h2>
            <p>Initializing your learning experience...</p>
        </div>
    </div>
    
    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <div class="logo">
                <span>üéØ</span>
                <span>VoiceCards</span>
            </div>
            <div class="nav-menu">
                <div class="nav-item active" onclick="showSection('study')">Study</div>
                <div class="nav-item" onclick="showSection('decks')">Decks</div>
                <div class="nav-item" onclick="showSection('analytics')">Analytics</div>
                <div class="nav-item" onclick="showSection('settings')">Settings</div>
                <div class="nav-item" id="syncStatus">
                    <span id="syncIcon">‚òÅÔ∏è</span>
                    <span id="syncText">Synced</span>
                </div>
            </div>
        </div>
    </nav>
    
    <!-- Hands-Free Status Bar (Mobile) -->
    <div class="hands-free-status" id="handsFreeStatusMobile">
        <div>üéôÔ∏è Hands-Free Mode Active</div>
        <div style="font-size: 12px; font-weight: 400; margin-top: 4px;" id="handsFreeStatusText">Say: "Easy", "Good", "Hard", "Repeat", "Show", or "Stop"</div>
    </div>
    
    <!-- Onboarding -->
    <div class="app-container" id="onboarding">
        <div class="onboarding-container">
            <div class="onboarding-step active" id="step1">
                <h1 class="onboarding-title">Welcome to VoiceCards! üéâ</h1>
                <p class="onboarding-description">
                    Learn anything faster with AI-powered voice flashcards and scientifically proven spaced repetition.
                </p>
                <div class="feature-grid">
                    <div class="feature-card" onclick="selectFeature(this)">
                        <div class="feature-icon">üó£Ô∏è</div>
                        <div>Voice Learning</div>
                    </div>
                    <div class="feature-card" onclick="selectFeature(this)">
                        <div class="feature-icon">üß†</div>
                        <div>Smart Repetition</div>
                    </div>
                    <div class="feature-card" onclick="selectFeature(this)">
                        <div class="feature-icon">üìä</div>
                        <div>Progress Analytics</div>
                    </div>
                    <div class="feature-card" onclick="selectFeature(this)">
                        <div class="feature-icon">üåê</div>
                        <div>Multi-language</div>
                    </div>
                </div>
                <button class="control-btn btn-primary" onclick="nextOnboardingStep()">
                    Get Started ‚Üí
                </button>
            </div>
            
            <div class="onboarding-step" id="step2">
                <h1 class="onboarding-title">Choose Your Learning Path</h1>
                <p class="onboarding-description">
                    What would you like to learn today?
                </p>
                <div class="feature-grid">
                    <div class="feature-card" onclick="selectDeck('japanese')">
                        <div class="feature-icon">üáØüáµ</div>
                        <div>Japanese</div>
                    </div>
                    <div class="feature-card" onclick="selectDeck('medical')">
                        <div class="feature-icon">‚öïÔ∏è</div>
                        <div>Medical Terms</div>
                    </div>
                    <div class="feature-card" onclick="selectDeck('spanish')">
                        <div class="feature-icon">üá™üá∏</div>
                        <div>Spanish</div>
                    </div>
                    <div class="feature-card" onclick="showImportModal()">
                        <div class="feature-icon">üì•</div>
                        <div>Import Deck</div>
                    </div>
                </div>
                <button class="control-btn btn-primary" onclick="completeOnboarding()">
                    Start Learning ‚Üí
                </button>
            </div>
        </div>
    </div>
    
    <!-- Study Section -->
    <div class="app-container" id="study">
        <div class="dashboard-grid">
            <div class="sidebar">
                <div class="user-profile">
                    <div class="user-avatar">üë§</div>
                    <div class="user-name">Learning Hero</div>
                    <div class="user-level">Level 5 ‚Ä¢ 1,250 XP</div>
                </div>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="todayCards">0</div>
                        <div class="stat-label">Today</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="streakDays">0</div>
                        <div class="stat-label">Streak</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="mastered">0</div>
                        <div class="stat-label">Mastered</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="accuracy">0%</div>
                        <div class="stat-label">Accuracy</div>
                    </div>
                </div>
                
                <div class="deck-list">
                    <h3 style="margin-bottom: 15px;">Active Decks</h3>
                    <div class="deck-item" onclick="startSession('japanese')">
                        <span class="deck-name">üáØüáµ Japanese Core</span>
                        <span class="deck-count">25 due</span>
                    </div>
                    <div class="deck-item" onclick="startSession('medical')">
                        <span class="deck-name">‚öïÔ∏è Medical Terms</span>
                        <span class="deck-count">12 due</span>
                    </div>
                    <div class="deck-item" onclick="startSession('spanish')">
                        <span class="deck-name">üá™üá∏ Spanish Basics</span>
                        <span class="deck-count">8 due</span>
                    </div>
                </div>
            </div>
            
            <div class="main-content">
                <div class="study-header">
                    <h2>Study Session</h2>
                    <div class="session-info">
                        <div class="session-stat">
                            <span class="session-stat-value" id="sessionCards">0</span>
                            <span class="session-stat-label">Cards</span>
                        </div>
                        <div class="session-stat">
                            <span class="session-stat-value" id="sessionTime">0:00</span>
                            <span class="session-stat-label">Time</span>
                        </div>
                        <div class="session-stat">
                            <span class="session-stat-value" id="sessionAccuracy">-</span>
                            <span class="session-stat-label">Accuracy</span>
                        </div>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                    </div>
                </div>
                
                <div class="card-container">
                    <div class="card-3d">
                        <div class="card-inner" id="cardInner">
                            <div class="card-face card-front">
                                <div class="card-text" id="cardFront">Ready to learn?</div>
                                <div class="card-subtext" id="cardHint">Click start to begin</div>
                            </div>
                            <div class="card-face card-back">
                                <div class="card-text" id="cardBack">Answer</div>
                                <div class="card-subtext" id="cardDetails">Details</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="voice-visualizer" id="voiceVisualizer">
                        <div class="voice-bar" style="height: 20px;"></div>
                        <div class="voice-bar" style="height: 30px;"></div>
                        <div class="voice-bar" style="height: 40px;"></div>
                        <div class="voice-bar" style="height: 35px;"></div>
                        <div class="voice-bar" style="height: 25px;"></div>
                        <div class="voice-bar" style="height: 45px;"></div>
                        <div class="voice-bar" style="height: 30px;"></div>
                        <div class="voice-bar" style="height: 20px;"></div>
                    </div>
                    
                    <div class="control-panel">
                        <button class="control-btn btn-primary" id="startBtn" onclick="startSession()">
                            <span>‚ñ∂Ô∏è</span> Start
                        </button>
                        <button class="control-btn btn-voice" id="handsFreeBtn" onclick="toggleHandsFreeMode()" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%);">
                            <span>üéôÔ∏è</span> Hands-Free
                        </button>
                        <button class="control-btn btn-voice" id="voiceBtn" onclick="toggleVoice()">
                            <span>üé§</span> Voice
                        </button>
                        <button class="control-btn btn-success" id="easyBtn" onclick="rateCard(5)">
                            <span>‚úÖ</span> Easy
                        </button>
                        <button class="control-btn btn-warning" id="goodBtn" onclick="rateCard(3)">
                            <span>üëç</span> Good
                        </button>
                        <button class="control-btn btn-danger" id="hardBtn" onclick="rateCard(1)">
                            <span>üòÖ</span> Hard
                        </button>
                        <button class="control-btn btn-secondary" onclick="showCard()">
                            <span>üëÅÔ∏è</span> Show
                        </button>
                    </div>
                    <div id="handsFreeStatus" style="text-align: center; margin-top: 20px; padding: 15px; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; border-radius: var(--border-radius); display: none;">
                        <div style="font-weight: 600; margin-bottom: 8px;" id="handsFreeStatusTitle">üéôÔ∏è Hands-Free Mode Active</div>
                        <div style="font-size: 12px; opacity: 0.9;" id="handsFreeStatusText">
                            Say: "Easy", "Good", "Hard", "Repeat", "Show", or "Stop"
                        </div>
                        <div id="wakeWordIndicator" style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.2); border-radius: 8px; font-size: 11px; display: none;">
                            ‚è≥ Waiting for wake word: "Hey VoiceCards"
                        </div>
                    </div>
                    <div style="text-align: center; margin-top: 20px; color: var(--gray); font-size: 12px;">
                        <span>üí° Keyboard shortcuts: Space/Enter to flip, 1-5 to rate, V for voice</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Analytics Section -->
    <div class="app-container" id="analytics">
        <div class="main-content">
            <h2 style="margin-bottom: 30px;">Learning Analytics</h2>
            
            <div class="analytics-grid">
                <div class="metric-card">
                    <div class="metric-title">Cards Studied</div>
                    <div class="metric-value">1,247</div>
                    <div class="metric-change positive">
                        <span>‚Üë</span> 12% from last week
                    </div>
                </div>
                <div class="metric-card">
                    <div class="metric-title">Study Time</div>
                    <div class="metric-value">48h</div>
                    <div class="metric-change positive">
                        <span>‚Üë</span> 5h from last week
                    </div>
                </div>
                <div class="metric-card">
                    <div class="metric-title">Retention Rate</div>
                    <div class="metric-value">87%</div>
                    <div class="metric-change positive">
                        <span>‚Üë</span> 3% improvement
                    </div>
                </div>
                <div class="metric-card">
                    <div class="metric-title">Daily Average</div>
                    <div class="metric-value">45</div>
                    <div class="metric-change negative">
                        <span>‚Üì</span> 5 cards from goal
                    </div>
                </div>
            </div>
            
            <div class="chart-container">
                <div class="chart-header">
                    <h3 class="chart-title">Weekly Progress</h3>
                    <div class="chart-filters">
                        <button class="filter-btn active">Week</button>
                        <button class="filter-btn">Month</button>
                        <button class="filter-btn">Year</button>
                    </div>
                </div>
                <div class="chart">
                    <div class="chart-bar" style="height: 60%;">
                        <span class="chart-label">Mon</span>
                    </div>
                    <div class="chart-bar" style="height: 80%;">
                        <span class="chart-label">Tue</span>
                    </div>
                    <div class="chart-bar" style="height: 45%;">
                        <span class="chart-label">Wed</span>
                    </div>
                    <div class="chart-bar" style="height: 90%;">
                        <span class="chart-label">Thu</span>
                    </div>
                    <div class="chart-bar" style="height: 70%;">
                        <span class="chart-label">Fri</span>
                    </div>
                    <div class="chart-bar" style="height: 85%;">
                        <span class="chart-label">Sat</span>
                    </div>
                    <div class="chart-bar" style="height: 50%;">
                        <span class="chart-label">Sun</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Settings Section -->
    <div class="app-container" id="settings">
        <div class="main-content">
            <h2 style="margin-bottom: 30px;">Settings</h2>
            
            <div class="settings-panel">
                <div class="setting-group">
                    <h3 class="setting-group-title">Learning Preferences</h3>
                    
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-label">Voice Mode</div>
                            <div class="setting-description">Enable voice input and output for hands-free learning</div>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="voiceEnabled" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-label">Hands-Free Mode (Beta)</div>
                            <div class="setting-description">Perfect for driving or washing dishes. Use voice commands: "Easy", "Good", "Hard", "Repeat", "Show", "Stop"</div>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="handsFreeEnabled">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-label">Wake Word Mode</div>
                            <div class="setting-description">Say "Hey VoiceCards" before each command. Prevents accidental activation while talking.</div>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="wakeWordEnabled">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-label">Background Audio</div>
                            <div class="setting-description">Keep audio playing when screen is locked (for hands-free use)</div>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="backgroundAudioEnabled" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-label">Auto-pronunciation</div>
                            <div class="setting-description">Automatically play card pronunciation</div>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="autoPronounce" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-label">Conversational AI Mode</div>
                            <div class="setting-description">Get AI-powered hints, explanations, and natural conversations</div>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="conversationalMode" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
                
                <div class="setting-group">
                    <h3 class="setting-group-title">AI Configuration</h3>
                    
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-label">AI Provider</div>
                            <div class="setting-description">Choose your AI service provider</div>
                        </div>
                        <select id="aiProvider" style="padding: 8px; border-radius: 8px; border: 1px solid #e5e7eb;" onchange="saveAISettings()">
                            <option value="anthropic">Anthropic Claude</option>
                            <option value="openai">OpenAI GPT</option>
                            <option value="gemini">Google Gemini</option>
                        </select>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-label">Gemini API Key</div>
                            <div class="setting-description">For Gemini Live API (stored locally)</div>
                        </div>
                        <input type="password" id="geminiApiKey" placeholder="Enter your Gemini API key" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #e5e7eb;" onchange="saveAISettings()">
                        <div style="margin-top: 8px; font-size: 12px; color: var(--gray);">
                            <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" style="color: var(--primary);">Get Gemini API Key</a>
                        </div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-label">API Key</div>
                            <div class="setting-description">Your API key for conversational features (stored locally)</div>
                        </div>
                        <input type="password" id="aiApiKey" placeholder="Enter your API key" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #e5e7eb;" onchange="saveAISettings()">
                        <div style="margin-top: 8px; font-size: 12px; color: var(--gray);">
                            <a href="https://console.anthropic.com/" target="_blank" rel="noopener noreferrer" style="color: var(--primary);">Get Anthropic API Key</a> | 
                            <a href="https://platform.openai.com/api-keys" target="_blank" rel="noopener noreferrer" style="color: var(--primary);">Get OpenAI API Key</a>
                        </div>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-label">Conversational Features</div>
                            <div class="setting-description">Enable AI explanations, hints, and Q&A</div>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="conversationalFeaturesEnabled" checked onchange="saveAISettings()">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-label">Gemini Live API (Beta)</div>
                            <div class="setting-description">Use Google's Live API for real-time voice conversations with native audio streaming. Requires Gemini API key. <a href="https://ai.google.dev/gemini-api/docs/live" target="_blank" rel="noopener noreferrer" style="color: var(--primary);">Learn more</a></div>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="useGeminiLiveAPI" onchange="saveAISettings()">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-label">OpenAI Realtime API (Beta)</div>
                            <div class="setting-description">Use OpenAI Agents SDK for real-time voice conversations with WebRTC. Requires OpenAI API key. <a href="https://openai.github.io/openai-agents-js/guides/voice-agents/quickstart/" target="_blank" rel="noopener noreferrer" style="color: var(--primary);">Learn more</a></div>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="useRealtimeAPI" onchange="saveAISettings()">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-label">Gemini Text-to-Speech</div>
                            <div class="setting-description">Use Gemini TTS for high-quality, natural-sounding speech (30 voices, 24 languages). Requires Gemini API key. <a href="https://ai.google.dev/gemini-api/docs/speech-generation" target="_blank" rel="noopener noreferrer" style="color: var(--primary);">Learn more</a></div>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="useGeminiTTS" onchange="saveAISettings()">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div class="setting-item" style="border-top: 2px solid #e5e7eb; padding-top: 20px; margin-top: 20px;">
                        <div class="setting-info">
                            <div class="setting-label">Account</div>
                            <div class="setting-description" id="accountInfo">
                                ${AppState.user.authenticated ? `Logged in as ${AppState.user.email}` : 'Not logged in'}
                            </div>
                        </div>
                        ${AppState.user.authenticated ? 
                            `<button class="control-btn btn-danger" onclick="logout()" style="padding: 8px 20px;">Logout</button>` :
                            `<button class="control-btn btn-primary" onclick="showLoginModal()" style="padding: 8px 20px;">Login / Register</button>`
                        }
                    </div>
                    
                    <div class="setting-item" id="geminiTTSVoiceContainer" style="display: none;">
                        <div class="setting-info">
                            <div class="setting-label">TTS Voice</div>
                            <div class="setting-description">Choose a voice for Gemini TTS. <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" style="color: var(--primary);">Preview voices</a></div>
                        </div>
                        <select id="geminiTTSVoice" style="padding: 8px; border-radius: 8px; border: 1px solid #e5e7eb; width: 100%;" onchange="saveAISettings()">
                            <optgroup label="Bright & Upbeat">
                                <option value="Zephyr">Zephyr - Bright</option>
                                <option value="Autonoe">Autonoe - Bright</option>
                                <option value="Puck">Puck - Upbeat</option>
                                <option value="Laomedeia">Laomedeia - Upbeat</option>
                                <option value="Fenrir">Fenrir - Excitable</option>
                            </optgroup>
                            <optgroup label="Firm & Clear">
                                <option value="Kore" selected>Kore - Firm</option>
                                <option value="Orus">Orus - Firm</option>
                                <option value="Alnilam">Alnilam - Firm</option>
                                <option value="Erinome">Erinome - Clear</option>
                                <option value="Iapetus">Iapetus - Clear</option>
                            </optgroup>
                            <optgroup label="Smooth & Warm">
                                <option value="Algieba">Algieba - Smooth</option>
                                <option value="Despina">Despina - Smooth</option>
                                <option value="Sulafat">Sulafat - Warm</option>
                                <option value="Aoede">Aoede - Breezy</option>
                            </optgroup>
                            <optgroup label="Informative & Knowledgeable">
                                <option value="Charon">Charon - Informative</option>
                                <option value="Rasalgethi">Rasalgethi - Informative</option>
                                <option value="Sadaltager">Sadaltager - Knowledgeable</option>
                            </optgroup>
                            <optgroup label="Friendly & Casual">
                                <option value="Achird">Achird - Friendly</option>
                                <option value="Umbriel">Umbriel - Easy-going</option>
                                <option value="Callirrhoe">Callirrhoe - Easy-going</option>
                                <option value="Zubenelgenubi">Zubenelgenubi - Casual</option>
                            </optgroup>
                            <optgroup label="Other Styles">
                                <option value="Leda">Leda - Youthful</option>
                                <option value="Enceladus">Enceladus - Breathy</option>
                                <option value="Algenib">Algenib - Gravelly</option>
                                <option value="Achernar">Achernar - Soft</option>
                                <option value="Gacrux">Gacrux - Mature</option>
                                <option value="Pulcherrima">Pulcherrima - Forward</option>
                                <option value="Vindemiatrix">Vindemiatrix - Gentle</option>
                                <option value="Sadachbia">Sadachbia - Lively</option>
                                <option value="Schedar">Schedar - Even</option>
                            </optgroup>
                        </select>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-label">Offline Mode</div>
                            <div class="setting-description">Download decks for offline study</div>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="offlineMode">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
                
                <div class="setting-group">
                    <h3 class="setting-group-title">Spaced Repetition</h3>
                    
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-label">New Cards Per Day</div>
                            <div class="setting-description">Maximum number of new cards to introduce daily</div>
                        </div>
                        <input type="number" value="20" min="1" max="100" style="width: 60px; padding: 5px;">
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-label">Review Limit</div>
                            <div class="setting-description">Maximum reviews per day (0 = unlimited)</div>
                        </div>
                        <input type="number" value="100" min="0" max="500" style="width: 60px; padding: 5px;">
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-label">Learning Steps</div>
                            <div class="setting-description">Minutes between learning repetitions</div>
                        </div>
                        <input type="text" value="1 10 60" style="width: 100px; padding: 5px;">
                    </div>
                </div>
                
                <div class="setting-group">
                    <h3 class="setting-group-title">Voice Settings</h3>
                    
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-label">Voice Selection</div>
                            <div class="setting-description">Choose your preferred AI voice</div>
                        </div>
                        <select style="padding: 5px; border-radius: 5px;">
                            <option>Natural - Female</option>
                            <option>Natural - Male</option>
                            <option>Energetic - Female</option>
                            <option>Calm - Male</option>
                        </select>
                    </div>
                    
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-label">Speech Rate</div>
                            <div class="setting-description">Adjust voice playback speed</div>
                        </div>
                        <input type="range" min="0.5" max="2" value="1" step="0.1" style="width: 100px;">
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Decks Section -->
    <div class="app-container" id="decks">
        <div class="main-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                <div>
                    <h2>Deck Management</h2>
                    <p>Browse, create, and import flashcard decks</p>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button class="control-btn btn-primary" onclick="showImportModal()">
                        <span>üì•</span> Import Deck
                    </button>
                    <button class="control-btn btn-secondary" onclick="showCreateDeckModal()">
                        <span>‚ûï</span> Create Deck
                    </button>
                </div>
            </div>
            
            <div id="decksList" class="decks-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 20px;">
                <!-- Decks will be dynamically loaded here -->
            </div>
        </div>
    </div>
    
    <!-- Import Modal -->
    <div class="modal" id="importModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Import Deck</h3>
                <button class="modal-close" onclick="closeModal('importModal')">√ó</button>
            </div>
            <p>Import from popular formats:</p>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 15px;">
                    <input type="file" id="csvFileInput" accept=".csv" style="display: none;" onchange="handleCSVImport(event)">
                    <button class="control-btn btn-secondary" style="width: 100%;" onclick="document.getElementById('csvFileInput').click()">
                        <span>üìÑ</span> CSV File
                    </button>
                </label>
                <label style="display: block; margin-bottom: 15px;">
                    <input type="file" id="jsonFileInput" accept=".json" style="display: none;" onchange="handleJSONImport(event)">
                    <button class="control-btn btn-secondary" style="width: 100%;" onclick="document.getElementById('jsonFileInput').click()">
                        <span>üìã</span> JSON File
                    </button>
                </label>
                <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e5e7eb;">
                    <label style="display: block; margin-bottom: 10px; font-weight: 500;">Or paste JSON:</label>
                    <textarea id="jsonPasteInput" placeholder='[{"front": "Question", "back": "Answer", "deck": "mydeck"}]' style="width: 100%; min-height: 150px; padding: 10px; border: 1px solid #e5e7eb; border-radius: 8px; font-family: monospace; font-size: 12px;"></textarea>
                    <button class="control-btn btn-primary" style="width: 100%; margin-top: 10px;" onclick="handleJSONPaste()">
                        Import from Text
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Create Deck Modal -->
    <div class="modal" id="createDeckModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Create New Deck</h3>
                <button class="modal-close" onclick="closeModal('createDeckModal')">√ó</button>
            </div>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 10px; font-weight: 500;">Deck Name:</label>
                <input type="text" id="newDeckName" placeholder="e.g., Spanish Vocabulary" style="width: 100%; padding: 10px; border: 1px solid #e5e7eb; border-radius: 8px; font-size: 16px;">
                <button class="control-btn btn-primary" style="width: 100%; margin-top: 20px;" onclick="createNewDeck()">
                    Create Deck
                </button>
            </div>
        </div>
    </div>
    
    <!-- Card Editor Modal -->
    <div class="modal" id="cardEditorModal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h3 class="modal-title" id="cardEditorTitle">Edit Card</h3>
                <button class="modal-close" onclick="closeModal('cardEditorModal')">√ó</button>
            </div>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 10px; font-weight: 500;">Front (Question):</label>
                <input type="text" id="cardFrontInput" placeholder="Question or term" style="width: 100%; padding: 10px; border: 1px solid #e5e7eb; border-radius: 8px; font-size: 16px; margin-bottom: 15px;">
                
                <label style="display: block; margin-bottom: 10px; font-weight: 500;">Back (Answer):</label>
                <textarea id="cardBackInput" placeholder="Answer or definition" style="width: 100%; min-height: 100px; padding: 10px; border: 1px solid #e5e7eb; border-radius: 8px; font-size: 16px; margin-bottom: 15px;"></textarea>
                
                <label style="display: block; margin-bottom: 10px; font-weight: 500;">Pronunciation (optional):</label>
                <input type="text" id="cardPronInput" placeholder="Pronunciation guide" style="width: 100%; padding: 10px; border: 1px solid #e5e7eb; border-radius: 8px; font-size: 16px; margin-bottom: 15px;">
                
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="control-btn btn-primary" style="flex: 1;" onclick="saveCard()">
                        Save Card
                    </button>
                    <button class="control-btn btn-danger" id="deleteCardBtn" style="flex: 1;" onclick="deleteCurrentCard()" style="display: none;">
                        Delete Card
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>
    
    <!-- Offline Banner -->
    <div class="offline-banner" id="offlineBanner">
        ‚ö†Ô∏è You're offline - Changes will sync when connection is restored
    </div>
    
    <script>
        // API Configuration
        const API_BASE_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
            ? 'http://localhost:5000/api'
            : '/api';
        
        // API Service
        class APIService {
            constructor() {
                this.baseURL = API_BASE_URL;
                this.token = localStorage.getItem('authToken') || null;
            }
            
            setToken(token) {
                this.token = token;
                if (token) {
                    localStorage.setItem('authToken', token);
                } else {
                    localStorage.removeItem('authToken');
                }
            }
            
            async request(endpoint, options = {}) {
                const url = `${this.baseURL}${endpoint}`;
                const headers = {
                    'Content-Type': 'application/json',
                    ...options.headers
                };
                
                if (this.token) {
                    headers['Authorization'] = `Bearer ${this.token}`;
                }
                
                try {
                    const response = await fetch(url, {
                        ...options,
                        headers
                    });
                    
                    if (response.status === 401) {
                        // Token expired or invalid
                        this.setToken(null);
                        showLoginModal();
                        throw new Error('Authentication required');
                    }
                    
                    const data = await response.json();
                    
                    if (!response.ok) {
                        throw new Error(data.error || 'Request failed');
                    }
                    
                    return data;
                } catch (error) {
                    console.error('API request failed:', error);
                    throw error;
                }
            }
            
            // Auth endpoints
            async register(email, password, name) {
                return this.request('/auth/register', {
                    method: 'POST',
                    body: JSON.stringify({ email, password, name })
                });
            }
            
            async login(email, password) {
                const data = await this.request('/auth/login', {
                    method: 'POST',
                    body: JSON.stringify({ email, password })
                });
                this.setToken(data.token);
                return data;
            }
            
            async getCurrentUser() {
                return this.request('/auth/me');
            }
            
            logout() {
                this.setToken(null);
            }
            
            // Deck endpoints
            async getDecks() {
                return this.request('/decks');
            }
            
            async getPublicDecks() {
                return this.request('/decks/public');
            }
            
            async getDeck(id) {
                return this.request(`/decks/${id}`);
            }
            
            async createDeck(name, description, isPublic = false) {
                return this.request('/decks', {
                    method: 'POST',
                    body: JSON.stringify({ name, description, is_public: isPublic })
                });
            }
            
            async updateDeck(id, updates) {
                return this.request(`/decks/${id}`, {
                    method: 'PUT',
                    body: JSON.stringify(updates)
                });
            }
            
            async deleteDeck(id) {
                return this.request(`/decks/${id}`, {
                    method: 'DELETE'
                });
            }
            
            // Card endpoints
            async getCards(deckId) {
                return this.request(`/cards/deck/${deckId}`);
            }
            
            async getCard(id) {
                return this.request(`/cards/${id}`);
            }
            
            async createCard(deckId, front, back, pronunciation = '') {
                return this.request('/cards', {
                    method: 'POST',
                    body: JSON.stringify({ deck_id: deckId, front, back, pronunciation })
                });
            }
            
            async updateCard(id, updates) {
                return this.request(`/cards/${id}`, {
                    method: 'PUT',
                    body: JSON.stringify(updates)
                });
            }
            
            async deleteCard(id) {
                return this.request(`/cards/${id}`, {
                    method: 'DELETE'
                });
            }
            
            // Session endpoints
            async getSessions() {
                return this.request('/sessions');
            }
            
            async createSession(deckId) {
                return this.request('/sessions', {
                    method: 'POST',
                    body: JSON.stringify({ deck_id: deckId })
                });
            }
            
            async updateSession(id, updates) {
                return this.request(`/sessions/${id}`, {
                    method: 'PUT',
                    body: JSON.stringify(updates)
                });
            }
            
            // Stats endpoints
            async getStats() {
                return this.request('/stats');
            }
        }
        
        const api = new APIService();
        
        // Initialize App State
        const AppState = {
            user: {
                id: null,
                email: null,
                name: 'Guest',
                authenticated: false,
                level: 5,
                xp: 1250,
                streak: 0,
                settings: {}
            },
            session: {
                active: false,
                deck: null,
                currentCard: null,
                queue: [],
                startTime: null,
                cardsStudied: 0,
                correctAnswers: 0,
                autoAdvance: false,
                autoPlay: true,
                sessionId: null
            },
            decks: {},
            syncStatus: 'synced',
            isListening: false,
            offlineMode: false
        };
        
        // Database class - Uses API with IndexedDB fallback
        class Database {
            constructor() {
                this.dbName = 'VoiceCardsDB';
                this.version = 1;
                this.db = null;
                this.useAPI = true; // Use API by default, fallback to IndexedDB if offline
            }
            
            async init() {
                // Initialize IndexedDB for offline fallback
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);
                    
                    request.onerror = () => {
                        console.warn('IndexedDB not available, using API only');
                        resolve(); // Don't fail, just use API
                    };
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve();
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        if (!db.objectStoreNames.contains('cards')) {
                            const cardStore = db.createObjectStore('cards', { keyPath: 'id' });
                            cardStore.createIndex('deck', 'deck', { unique: false });
                        }
                        
                        if (!db.objectStoreNames.contains('sessions')) {
                            db.createObjectStore('sessions', { keyPath: 'id', autoIncrement: true });
                        }
                        
                        if (!db.objectStoreNames.contains('settings')) {
                            db.createObjectStore('settings', { keyPath: 'key' });
                        }
                    };
                });
            }
            
            // Check if online
            isOnline() {
                return navigator.onLine && this.useAPI && AppState.user.authenticated;
            }
            
            // Deck methods
            async getDecks() {
                if (this.isOnline()) {
                    try {
                        return await api.getDecks();
                    } catch (error) {
                        console.warn('API failed, using IndexedDB:', error);
                        return this.getDecksOffline();
                    }
                }
                return this.getDecksOffline();
            }
            
            async getDecksOffline() {
                if (!this.db) return [];
                const transaction = this.db.transaction(['settings'], 'readonly');
                const store = transaction.objectStore('settings');
                const result = await new Promise((resolve) => {
                    const request = store.get('decks');
                    request.onsuccess = () => resolve(request.result?.value || {});
                });
                return Object.values(result);
            }
            
            async saveDeck(deck) {
                if (this.isOnline()) {
                    try {
                        if (deck.id) {
                            return await api.updateDeck(deck.id, deck);
                        } else {
                            return await api.createDeck(deck.name, deck.description, deck.is_public);
                        }
                    } catch (error) {
                        console.warn('API failed, saving offline:', error);
                        return this.saveDeckOffline(deck);
                    }
                }
                return this.saveDeckOffline(deck);
            }
            
            async saveDeckOffline(deck) {
                if (!this.db) return deck;
                const decks = await this.getDecksOffline();
                if (deck.id) {
                    const index = decks.findIndex(d => d.id === deck.id);
                    if (index >= 0) decks[index] = deck;
                    else decks.push(deck);
                } else {
                    deck.id = Date.now().toString();
                    decks.push(deck);
                }
                const transaction = this.db.transaction(['settings'], 'readwrite');
                const store = transaction.objectStore('settings');
                await store.put({ key: 'decks', value: Object.fromEntries(decks.map(d => [d.id, d])) });
                return deck;
            }
            
            async deleteDeck(deckId) {
                if (this.isOnline()) {
                    try {
                        await api.deleteDeck(deckId);
                        return;
                    } catch (error) {
                        console.warn('API failed, deleting offline:', error);
                    }
                }
                await this.deleteDeckOffline(deckId);
            }
            
            async deleteDeckOffline(deckId) {
                if (!this.db) return;
                const decks = await this.getDecksOffline();
                const filtered = decks.filter(d => d.id !== deckId);
                const transaction = this.db.transaction(['settings'], 'readwrite');
                const store = transaction.objectStore('settings');
                await store.put({ key: 'decks', value: Object.fromEntries(filtered.map(d => [d.id, d])) });
            }
            
            // Card methods
            async getCards(deckId) {
                if (this.isOnline()) {
                    try {
                        return await api.getCards(deckId);
                    } catch (error) {
                        console.warn('API failed, using IndexedDB:', error);
                        return this.getCardsOffline(deckId);
                    }
                }
                return this.getCardsOffline(deckId);
            }
            
            async getCardsOffline(deckId) {
                if (!this.db) return [];
                const transaction = this.db.transaction(['cards'], 'readonly');
                const store = transaction.objectStore('cards');
                const index = store.index('deck');
                return new Promise((resolve) => {
                    const request = index.getAll(deckId);
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => resolve([]);
                });
            }
            
            async saveCard(card) {
                if (this.isOnline()) {
                    try {
                        if (card.id && !card.id.startsWith('temp_')) {
                            return await api.updateCard(card.id, {
                                front: card.front,
                                back: card.back,
                                pronunciation: card.pronunciation
                            });
                        } else {
                            return await api.createCard(card.deck_id || card.deck, card.front, card.back, card.pronunciation || '');
                        }
                    } catch (error) {
                        console.warn('API failed, saving offline:', error);
                        return this.saveCardOffline(card);
                    }
                }
                return this.saveCardOffline(card);
            }
            
            async saveCardOffline(card) {
                if (!this.db) return card;
                if (!card.id) card.id = 'temp_' + Date.now();
                const transaction = this.db.transaction(['cards'], 'readwrite');
                const store = transaction.objectStore('cards');
                await store.put(card);
                return card;
            }
            
            async deleteCard(cardId) {
                if (this.isOnline()) {
                    try {
                        await api.deleteCard(cardId);
                        return;
                    } catch (error) {
                        console.warn('API failed, deleting offline:', error);
                    }
                }
                await this.deleteCardOffline(cardId);
            }
            
            async deleteCardOffline(cardId) {
                if (!this.db) return;
                const transaction = this.db.transaction(['cards'], 'readwrite');
                const store = transaction.objectStore('cards');
                await store.delete(cardId);
            }
            
            async saveSession(session) {
                if (this.isOnline() && session.deck_id) {
                    try {
                        if (session.id) {
                            await api.updateSession(session.id, {
                                ended_at: session.ended_at,
                                cards_studied: session.cardsStudied,
                                cards_correct: session.correctAnswers
                            });
                        } else {
                            const result = await api.createSession(session.deck_id);
                            session.id = result.id;
                        }
                        return session;
                    } catch (error) {
                        console.warn('API failed, saving offline:', error);
                    }
                }
                return this.saveSessionOffline(session);
            }
            
            async saveSessionOffline(session) {
                if (!this.db) return session;
                if (!session.id) session.id = Date.now();
                const transaction = this.db.transaction(['sessions'], 'readwrite');
                const store = transaction.objectStore('sessions');
                await store.add(session);
                return session;
            }
        }
        
        const db = new Database();
        
        // Auth functions
        let currentAuthTab = 'login';
        
        function showAuthTab(tab) {
            currentAuthTab = tab;
            document.getElementById('loginTab').style.borderBottom = tab === 'login' ? '2px solid var(--primary)' : 'none';
            document.getElementById('loginTab').style.color = tab === 'login' ? 'var(--primary)' : 'var(--gray)';
            document.getElementById('loginTab').style.fontWeight = tab === 'login' ? '600' : '400';
            document.getElementById('registerTab').style.borderBottom = tab === 'register' ? '2px solid var(--primary)' : 'none';
            document.getElementById('registerTab').style.color = tab === 'register' ? 'var(--primary)' : 'var(--gray)';
            document.getElementById('registerTab').style.fontWeight = tab === 'register' ? '600' : '400';
            
            document.getElementById('nameField').style.display = tab === 'register' ? 'block' : 'none';
            document.getElementById('authModalTitle').textContent = tab === 'login' ? 'Login' : 'Register';
            document.getElementById('authSubmitText').textContent = tab === 'login' ? 'Login' : 'Register';
            document.getElementById('authError').style.display = 'none';
        }
        
        async function handleAuth(event) {
            event.preventDefault();
            const email = document.getElementById('authEmail').value;
            const password = document.getElementById('authPassword').value;
            const name = document.getElementById('authName').value;
            const errorDiv = document.getElementById('authError');
            
            try {
                let result;
                if (currentAuthTab === 'register') {
                    result = await api.register(email, password, name);
                    showToast('Account created! Please login.', 'success');
                    showAuthTab('login');
                } else {
                    result = await api.login(email, password);
                    AppState.user = {
                        ...AppState.user,
                        id: result.user.id,
                        email: result.user.email,
                        name: result.user.name || result.user.email.split('@')[0],
                        authenticated: true
                    };
                    closeAuthModal();
                    showToast('Welcome back!', 'success');
                    await loadUserData();
                }
            } catch (error) {
                errorDiv.textContent = error.message || 'Authentication failed';
                errorDiv.style.display = 'block';
            }
        }
        
        function showLoginModal() {
            document.getElementById('authModal').style.display = 'flex';
            showAuthTab('login');
        }
        
        function closeAuthModal() {
            document.getElementById('authModal').style.display = 'none';
            document.getElementById('authForm').reset();
            document.getElementById('authError').style.display = 'none';
        }
        
        async function logout() {
            api.logout();
            AppState.user = {
                ...AppState.user,
                id: null,
                email: null,
                name: 'Guest',
                authenticated: false
            };
            AppState.decks = {};
            showToast('Logged out', 'info');
            renderDecks();
            showLoginModal();
        }
        
        async function loadUserData() {
            if (!AppState.user.authenticated) return;
            
            try {
                const decks = await db.getDecks();
                AppState.decks = {};
                decks.forEach(deck => {
                    AppState.decks[deck.id] = {
                        id: deck.id,
                        name: deck.name,
                        description: deck.description,
                        isPublic: deck.is_public,
                        cards: []
                    };
                });
                renderDecks();
            } catch (error) {
                console.error('Failed to load user data:', error);
            }
        }
        
        // Speech Recognition & Synthesis
        class VoiceEngine {
            constructor() {
                this.recognition = null;
                this.synthesis = window.speechSynthesis;
                this.handsFreeMode = false;
                this.continuousListening = false;
                this.wakeWordMode = false;
                this.wakeWordDetected = false;
                this.audioContext = null;
                this.userInteracted = false; // Track if user has interacted with the page
                this.initAudioContext();
                this.initRecognition();
                
                // Track user interactions to enable AudioContext
                const enableAudio = () => {
                    this.userInteracted = true;
                    // Remove listeners after first interaction
                    document.removeEventListener('click', enableAudio);
                    document.removeEventListener('touchstart', enableAudio);
                    document.removeEventListener('keydown', enableAudio);
                };
                document.addEventListener('click', enableAudio, { once: true });
                document.addEventListener('touchstart', enableAudio, { once: true });
                document.addEventListener('keydown', enableAudio, { once: true });
            }
            
            initAudioContext() {
                // Don't create audio context immediately - wait for user interaction
                // AudioContext requires user gesture due to browser autoplay policies
                this.audioContext = null;
            }
            
            async ensureAudioContext() {
                // Create audio context on first use (after user interaction)
                // Note: This should only be called after a user gesture (click, touch, etc.)
                if (!this.audioContext) {
                    try {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        // AudioContext starts in 'suspended' state and needs resume() after user gesture
                        // We'll resume it when actually needed (in speak or playAudio)
                    } catch (e) {
                        console.warn('Audio context creation failed:', e);
                        return false;
                    }
                }
                
                // Resume if suspended (requires user interaction)
                // This is safe to call after user gesture
                if (this.audioContext.state === 'suspended') {
                    try {
                        await this.audioContext.resume();
                    } catch (e) {
                        // User interaction required - this is expected before first use
                        console.warn('AudioContext resume failed (needs user gesture):', e);
                        return false;
                    }
                }
                
                return true;
            }
            
            keepAudioAlive() {
                // Periodically resume audio context to prevent it from suspending
                // Only attempt if user has interacted with the page
                if (this.audioContext && this.userInteracted && this.audioContext.state === 'suspended') {
                    // Silently try to resume - will fail gracefully if no user gesture
                    this.audioContext.resume().catch(() => {
                        // Ignore - this is expected if no recent user interaction
                    });
                }
            }
            
            initRecognition() {
                if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    this.recognition = new SpeechRecognition();
                    this.recognition.continuous = true; // Changed to continuous for hands-free
                    this.recognition.interimResults = false; // Only final results for commands
                    this.recognition.lang = 'en-US';
                    
                    this.recognition.onresult = this.handleResult.bind(this);
                    this.recognition.onerror = this.handleError.bind(this);
                    this.recognition.onend = this.handleEnd.bind(this);
                }
            }
            
            async speak(text, lang = 'en-US', priority = false) {
                // Try Gemini TTS first if enabled (check if geminiTTS exists)
                // Note: This requires AudioContext which needs user interaction
                if (typeof geminiTTS !== 'undefined' && geminiTTS.enabled && geminiTTS.apiKey) {
                    try {
                        // Ensure AudioContext is ready (will be created/resumed on first user interaction)
                        await this.ensureAudioContext();
                        
                        // Stop any current speech if priority
                        if (priority) {
                            this.synthesis.cancel();
                        }
                        await geminiTTS.speak(text, lang);
                        return;
                    } catch (error) {
                        // Fallback to browser TTS if Gemini TTS fails (e.g., AudioContext not ready)
                        console.log('Falling back to browser TTS:', error.message);
                        // Continue to browser TTS fallback below
                    }
                }
                
                // Use browser Speech Synthesis API (fallback or default)
                return new Promise((resolve) => {
                    // Speech Synthesis API doesn't require AudioContext, but we'll try to initialize it
                    // for future use (e.g., Gemini TTS). This is safe as it won't block speech synthesis.
                    this.ensureAudioContext().catch(() => {
                        // Audio context not ready - continue anyway with speech synthesis
                        // This is fine - Speech Synthesis API works independently
                    });
                    
                    // Stop any current speech if priority
                    if (priority) {
                        this.synthesis.cancel();
                    }
                    
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.lang = lang;
                    utterance.rate = parseFloat(document.getElementById('speechRate')?.value || 1);
                    utterance.volume = 1.0;
                    
                    // Enable background audio
                    utterance.onstart = async () => {
                        // Try to resume audio context if needed (for future audio playback)
                        // This happens after user interaction (speech started), so it's safe
                        if (this.audioContext && this.audioContext.state === 'suspended') {
                            try {
                                await this.audioContext.resume();
                            } catch (e) {
                                // Ignore - AudioContext will be ready on next user interaction
                            }
                        }
                    };
                    
                    utterance.onend = () => {
                        resolve();
                    };
                    utterance.onerror = () => resolve(); // Resolve even on error
                    this.synthesis.speak(utterance);
                });
            }
            
            async speakWithDelay(text, delay = 500, lang = 'en-US') {
                await new Promise(resolve => setTimeout(resolve, delay));
                return this.speak(text, lang);
            }
            
            startListening() {
                if (this.recognition && !this.continuousListening) {
                    this.continuousListening = true;
                    AppState.isListening = true;
                    try {
                        this.recognition.start();
                        document.getElementById('voiceVisualizer')?.classList.add('active');
                        document.getElementById('voiceBtn')?.classList.add('listening');
                    } catch (e) {
                        // Already listening
                        console.log('Recognition already started');
                    }
                }
            }
            
            stopListening() {
                if (this.recognition && this.continuousListening) {
                    this.continuousListening = false;
                    AppState.isListening = false;
                    this.recognition.stop();
                    document.getElementById('voiceVisualizer')?.classList.remove('active');
                    document.getElementById('voiceBtn')?.classList.remove('listening');
                }
            }
            
            async startHandsFreeMode(useWakeWord = false) {
                this.handsFreeMode = true;
                this.wakeWordMode = useWakeWord;
                this.wakeWordDetected = !useWakeWord; // If wake word mode, wait for wake word
                
                // Priority order: Gemini Live > OpenAI Realtime > Standard mode
                const useGeminiLive = typeof geminiLiveAgent !== 'undefined' && 
                                     localStorage.getItem('useGeminiLiveAPI') === 'true' && 
                                     geminiLiveAgent.apiKey;
                const useRealtime = typeof openAIRealtimeAgent !== 'undefined' && 
                                    localStorage.getItem('useRealtimeAPI') === 'true' && 
                                    openAIRealtimeAgent.apiKey;
                
                if (useGeminiLive) {
                    // Use Gemini Live API (highest priority)
                    const connected = await geminiLiveAgent.connect();
                    if (connected) {
                        this.speak('Gemini Live API activated. You can now have natural voice conversations!', 'en-US', true);
                        document.getElementById('wakeWordIndicator').style.display = 'none';
                        return;
                    } else {
                        this.speak('Gemini Live API connection failed. Trying OpenAI Realtime...', 'en-US', true);
                    }
                }
                
                if (useRealtime) {
                    // Use OpenAI Realtime API
                    const connected = await openAIRealtimeAgent.connect();
                    if (connected) {
                        this.speak('OpenAI Realtime API activated. You can now have natural voice conversations!', 'en-US', true);
                        document.getElementById('wakeWordIndicator').style.display = 'none';
                        return;
                    } else {
                        this.speak('OpenAI Realtime API connection failed. Using standard mode.', 'en-US', true);
                    }
                }
                
                // Standard mode (fallback)
                if (useWakeWord) {
                    this.startListening();
                    document.getElementById('wakeWordIndicator').style.display = 'block';
                    this.speak('Wake word mode activated. Say "Hey VoiceCards" to activate commands, or "go to sleep" to disable.', 'en-US', true);
                } else {
                    this.startListening();
                    document.getElementById('wakeWordIndicator').style.display = 'none';
                    this.speak('Hands-free mode activated. Say "easy", "good", or "hard" to rate cards. Say "repeat" to hear again, or "stop" to end session. Say "help" for all commands.', 'en-US', true);
                }
            }
            
            stopHandsFreeMode() {
                this.handsFreeMode = false;
                this.wakeWordMode = false;
                this.wakeWordDetected = false;
                this.stopListening();
                document.getElementById('wakeWordIndicator').style.display = 'none';
                
                // Disconnect AI agents if connected
                if (typeof geminiLiveAgent !== 'undefined' && geminiLiveAgent.enabled) {
                    geminiLiveAgent.disconnect();
                }
                if (typeof openAIRealtimeAgent !== 'undefined' && openAIRealtimeAgent.enabled) {
                    openAIRealtimeAgent.disconnect();
                }
            }
            
            handleResult(event) {
                const last = event.results.length - 1;
                const transcript = event.results[last][0].transcript.trim().toLowerCase();
                
                if (event.results[last].isFinal) {
                    if (this.handsFreeMode && AppState.session.active) {
                        this.processVoiceCommand(transcript).catch(err => {
                            console.error('Voice command error:', err);
                        });
                    } else {
                        this.processAnswer(transcript).catch(err => {
                            console.error('Answer processing error:', err);
                        });
                    }
                }
            }
            
            handleError(event) {
                console.error('Speech recognition error:', event.error);
                
                // Don't stop in hands-free mode, just restart
                if (this.handsFreeMode && event.error !== 'no-speech') {
                    setTimeout(() => {
                        if (this.handsFreeMode && this.recognition) {
                            try {
                                this.recognition.start();
                            } catch (e) {
                                // Already started
                            }
                        }
                    }, 100);
                } else {
                    showToast('Could not understand. Please try again.', 'error');
                    if (!this.handsFreeMode) {
                        this.stopListening();
                    }
                }
            }
            
            handleEnd() {
                // Auto-restart in hands-free mode
                if (this.handsFreeMode && this.continuousListening) {
                    setTimeout(() => {
                        if (this.handsFreeMode && this.recognition) {
                            try {
                                this.recognition.start();
                            } catch (e) {
                                // Already started
                            }
                        }
                    }, 100);
                } else if (!this.handsFreeMode) {
                    this.stopListening();
                }
            }
            
            async processVoiceCommand(transcript) {
                const lowerTranscript = transcript.toLowerCase();
                
                // Check for session start commands (even outside active session)
                if (!AppState.session.active) {
                    const startCommands = ['start session', 'start studying', 'begin session', 'let\'s start', 'start'];
                    for (const cmd of startCommands) {
                        if (lowerTranscript.includes(cmd)) {
                            await this.speak('Starting session', 'en-US', true);
                            setTimeout(() => startSession(), 500);
                            return;
                        }
                    }
                }
                
                // Wake word detection
                if (this.wakeWordMode && !this.wakeWordDetected) {
                    const wakeWords = ['hey voicecards', 'hey voice cards', 'voicecards', 'voice cards'];
                    for (const wakeWord of wakeWords) {
                        if (lowerTranscript.includes(wakeWord)) {
                            this.wakeWordDetected = true;
                            document.getElementById('wakeWordIndicator').style.display = 'none';
                            this.speak('Yes, I\'m listening', 'en-US', true);
                            return;
                        }
                    }
                    return; // Ignore commands until wake word detected
                }
                
                // Expanded natural language commands
                const commands = {
                    // Rating commands
                    'easy': async () => { await this.speak('Easy', 'en-US', true); await rateCard(5); },
                    'good': async () => { await this.speak('Good', 'en-US', true); await rateCard(3); },
                    'hard': async () => { await this.speak('Hard', 'en-US', true); await rateCard(1); },
                    'again': async () => { await this.speak('Again', 'en-US', true); await rateCard(1); },
                    
                    // Natural language rating
                    'i know this': async () => { await rateCard(5); },
                    'i know it': async () => { await rateCard(5); },
                    'i remember': async () => { await rateCard(5); },
                    'i forgot': async () => { await rateCard(1); },
                    'i don\'t know': async () => { await rateCard(1); },
                    'i don\'t remember': async () => { await rateCard(1); },
                    'got it': async () => { await rateCard(3); },
                    'okay': async () => { await rateCard(3); },
                    'correct': async () => { await rateCard(5); },
                    'wrong': async () => { await rateCard(1); },
                    
                    // Navigation commands
                    'repeat': async () => { await this.repeatCard(); },
                    'say again': async () => { await this.repeatCard(); },
                    'what was that': async () => { await this.repeatCard(); },
                    'what did you say': async () => { await this.repeatCard(); },
                    'next': async () => { if (AppState.session.currentCard) await rateCard(3); },
                    'next card': async () => { if (AppState.session.currentCard) await rateCard(3); },
                    'skip': async () => { if (AppState.session.currentCard) await rateCard(3); },
                    
                    // Conversational commands
                    'hint': async () => { await this.getHint(); },
                    'give me a hint': async () => { await this.getHint(); },
                    'help me': async () => { await this.getHint(); },
                    'i need help': async () => { await this.getHint(); },
                    
                    // Show answer commands
                    'show': async () => { await showCard(); },
                    'show answer': async () => { await showCard(); },
                    'reveal': async () => { await showCard(); },
                    'tell me': async () => { await showCard(); },
                    'what\'s the answer': async () => { await showCard(); },
                    
                    // Session control
                    'stop': () => { this.speak('Stopping session', 'en-US', true); endSession(); this.stopHandsFreeMode(); },
                    'end session': () => { this.speak('Ending session', 'en-US', true); endSession(); this.stopHandsFreeMode(); },
                    'finish': () => { this.speak('Finishing session', 'en-US', true); endSession(); this.stopHandsFreeMode(); },
                    'pause': () => { this.speak('Paused', 'en-US', true); this.stopListening(); },
                    'resume': () => { this.speak('Resumed', 'en-US', true); this.startListening(); },
                    'continue': () => { this.speak('Continuing', 'en-US', true); this.startListening(); },
                    
                    // Help commands
                    'help': () => { this.speakHelp(); },
                    'what can i say': () => { this.speakHelp(); },
                    'commands': () => { this.speakHelp(); },
                    
                    // Wake word reset (if in wake word mode)
                    'go to sleep': () => { 
                        if (this.wakeWordMode) {
                            this.wakeWordDetected = false;
                            document.getElementById('wakeWordIndicator').style.display = 'block';
                            this.speak('Going to sleep. Say "Hey VoiceCards" to wake me up.', 'en-US', true);
                        }
                    }
                };
                
                // Check for command matches (case-insensitive, partial match)
                // lowerTranscript already declared at function start
                for (const [command, action] of Object.entries(commands)) {
                    if (lowerTranscript.includes(command)) {
                        await action();
                        return;
                    }
                }
                
                // If no command matched, check if it's a question (starts with question words)
                const questionWords = ['what', 'why', 'how', 'when', 'where', 'who', 'explain', 'tell me about', 'can you'];
                const isQuestion = questionWords.some(word => lowerTranscript.startsWith(word));
                
                if (isQuestion && AppState.session.currentCard && conversationalAgent.enabled) {
                    // Handle conversational questions
                    const answer = await conversationalAgent.answerQuestion(transcript, AppState.session.currentCard);
                    if (answer) {
                        await this.speak(answer, 'en-US', true);
                    } else {
                        await this.processAnswer(transcript);
                    }
                } else if (AppState.session.currentCard) {
                    // Treat as answer attempt
                    await this.processAnswer(transcript);
                }
            }
            
            async speakHelp() {
                const helpText = 'You can say: Easy, Good, or Hard to rate cards. Say Repeat to hear again. Say Show to see the answer. Say Stop to end the session.';
                await this.speak(helpText, 'en-US', true);
            }
            
            async repeatCard() {
                if (AppState.session.currentCard) {
                    const card = AppState.session.currentCard;
                    const lang = AppState.session.deck === 'japanese' ? 'ja-JP' : 
                                AppState.session.deck === 'spanish' ? 'es-ES' : 'en-US';
                    
                    // In hands-free mode, repeat BOTH sides
                    if (this.handsFreeMode) {
                        await this.speak('Repeating card', 'en-US', true);
                        await this.speakWithDelay(card.front, lang, false);
                        if (card.pronunciation) {
                            await this.speakWithDelay(`Pronunciation: ${card.pronunciation}`, 300);
                        }
                        // Also speak the answer if card is flipped
                        if (document.getElementById('cardInner')?.classList.contains('flipped')) {
                            await this.speakWithDelay(`The answer is ${card.back}`, lang, false);
                        }
                    } else {
                        await this.speak(card.front, lang, true);
                        if (card.pronunciation) {
                            await this.speakWithDelay(`Pronunciation: ${card.pronunciation}`, 300);
                        }
                    }
                }
            }
            
            async getHint() {
                if (!AppState.session.currentCard) return;
                
                await this.speak('Let me think...', 'en-US', true);
                const hint = await conversationalAgent.getHint(AppState.session.currentCard);
                
                if (hint) {
                    await this.speak(hint, 'en-US', false);
                } else {
                    await this.speak('Here\'s a hint: think about the context and pronunciation', 'en-US', false);
                }
            }
            
            async processAnswer(transcript) {
                if (AppState.session.active && AppState.session.currentCard) {
                    const card = AppState.session.currentCard;
                    const correct = this.checkAnswer(transcript, card.back);
                    
                    if (correct) {
                        if (this.handsFreeMode) {
                            // In hands-free mode: speak assessment, then show answer, then rate
                            await this.speak('Correct!', 'en-US', true);
                            // Show and speak the answer
                            if (!document.getElementById('cardInner').classList.contains('flipped')) {
                                document.getElementById('cardInner').classList.add('flipped');
                            }
                            const lang = AppState.session.deck === 'japanese' ? 'ja-JP' : 
                                        AppState.session.deck === 'spanish' ? 'es-ES' : 'en-US';
                            await this.speakWithDelay(`The answer is ${card.back}`, lang, false);
                            
                            // Get conversational explanation if enabled
                            if (conversationalAgent.enabled) {
                                const explanation = await conversationalAgent.getExplanation(card, transcript, true);
                                if (explanation) {
                                    await this.speakWithDelay(explanation, 'en-US', false);
                                }
                            }
                            
                            await this.speakWithDelay('Marked as easy', 'en-US', false);
                        } else {
                            showToast('Correct! ' + transcript, 'success');
                        }
                        rateCard(5);
                    } else {
                        if (this.handsFreeMode) {
                            // In hands-free mode: speak assessment, then show answer, then rate
                            await this.speak('Not quite', 'en-US', true);
                            // Show and speak the answer
                            if (!document.getElementById('cardInner').classList.contains('flipped')) {
                                document.getElementById('cardInner').classList.add('flipped');
                            }
                            const lang = AppState.session.deck === 'japanese' ? 'ja-JP' : 
                                        AppState.session.deck === 'spanish' ? 'es-ES' : 'en-US';
                            await this.speakWithDelay(`The correct answer is ${card.back}`, lang, false);
                            
                            // Get conversational explanation if enabled
                            if (conversationalAgent.enabled) {
                                const explanation = await conversationalAgent.getExplanation(card, transcript, false);
                                if (explanation) {
                                    await this.speakWithDelay(explanation, 'en-US', false);
                                }
                            }
                            
                            await this.speakWithDelay('Marked as hard', 'en-US', false);
                        } else {
                            showToast('Not quite. You said: ' + transcript, 'error');
                        }
                        rateCard(1);
                    }
                }
            }
            
            checkAnswer(userAnswer, correctAnswer) {
                const normalize = (str) => str.toLowerCase().trim().replace(/[^\w\s]/gi, '');
                const normalizedAnswer = normalize(correctAnswer);
                const normalizedUser = normalize(userAnswer);
                
                // Exact match
                if (normalizedUser === normalizedAnswer) return true;
                
                // Partial match (contains answer)
                if (normalizedUser.includes(normalizedAnswer) || normalizedAnswer.includes(normalizedUser)) {
                    return true;
                }
                
                // Fuzzy match for longer answers
                if (normalizedAnswer.length > 10) {
                    const words = normalizedAnswer.split(' ');
                    const matchingWords = words.filter(word => normalizedUser.includes(word));
                    return matchingWords.length >= Math.ceil(words.length * 0.7); // 70% word match
                }
                
                return false;
            }
        }
        
        const voiceEngine = new VoiceEngine();
        
        // Conversational AI Agent
        class ConversationalAgent {
            constructor() {
                this.apiKey = localStorage.getItem('aiApiKey') || '';
                this.apiProvider = localStorage.getItem('aiApiProvider') || 'anthropic'; // 'anthropic' or 'openai'
                this.enabled = localStorage.getItem('conversationalMode') === 'true';
                this.conversationHistory = [];
            }
            
            async getExplanation(card, userAnswer, isCorrect) {
                if (!this.enabled || !this.apiKey) return null;
                
                const context = {
                    card: {
                        front: card.front,
                        back: card.back,
                        pronunciation: card.pronunciation || '',
                        deck: card.deck
                    },
                    userAnswer: userAnswer,
                    isCorrect: isCorrect,
                    sessionStats: {
                        cardsStudied: AppState.session.cardsStudied,
                        accuracy: AppState.session.cardsStudied > 0 
                            ? Math.round((AppState.session.correctAnswers / AppState.session.cardsStudied) * 100)
                            : 0
                    }
                };
                
                try {
                    if (this.apiProvider === 'anthropic') {
                        return await this.callAnthropicAPI(context);
                    } else {
                        return await this.callOpenAIAPI(context);
                    }
                } catch (error) {
                    console.error('AI API error:', error);
                    return null;
                }
            }
            
            async callAnthropicAPI(context) {
                const prompt = this.buildPrompt(context);
                
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': this.apiKey,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify({
                        model: 'claude-3-haiku-20240307',
                        max_tokens: 200,
                        messages: [{
                            role: 'user',
                            content: prompt
                        }]
                    })
                });
                
                if (!response.ok) throw new Error('API request failed');
                const data = await response.json();
                return data.content[0].text.trim();
            }
            
            async callOpenAIAPI(context) {
                const prompt = this.buildPrompt(context);
                
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${this.apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-3.5-turbo',
                        max_tokens: 200,
                        messages: [{
                            role: 'system',
                            content: 'You are a helpful language learning tutor. Provide brief, encouraging explanations.'
                        }, {
                            role: 'user',
                            content: prompt
                        }]
                    })
                });
                
                if (!response.ok) throw new Error('API request failed');
                const data = await response.json();
                return data.choices[0].message.content.trim();
            }
            
            buildPrompt(context) {
                const { card, userAnswer, isCorrect, sessionStats } = context;
                
                if (isCorrect) {
                    return `The user correctly answered "${card.front}" with "${userAnswer}". The correct answer is "${card.back}". 
                    Provide a brief, encouraging response (1-2 sentences) and maybe a fun fact or memory tip. 
                    Keep it conversational and supportive. Current session accuracy: ${sessionStats.accuracy}%.`;
                } else {
                    return `The user answered "${card.front}" with "${userAnswer}", but the correct answer is "${card.back}". 
                    Provide a brief, helpful explanation (2-3 sentences) that helps them understand the correct answer. 
                    Be encouraging and educational. Current session accuracy: ${sessionStats.accuracy}%.`;
                }
            }
            
            async getHint(card) {
                if (!this.enabled || !this.apiKey) return null;
                
                try {
                    const prompt = `The flashcard question is "${card.front}" and the answer is "${card.back}". 
                    Provide a helpful hint (1 sentence) that guides the user toward the answer without giving it away.`;
                    
                    if (this.apiProvider === 'anthropic') {
                        const response = await fetch('https://api.anthropic.com/v1/messages', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'x-api-key': this.apiKey,
                                'anthropic-version': '2023-06-01'
                            },
                            body: JSON.stringify({
                                model: 'claude-3-haiku-20240307',
                                max_tokens: 100,
                                messages: [{ role: 'user', content: prompt }]
                            })
                        });
                        const data = await response.json();
                        return data.content[0].text.trim();
                    } else {
                        const response = await fetch('https://api.openai.com/v1/chat/completions', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${this.apiKey}`
                            },
                            body: JSON.stringify({
                                model: 'gpt-3.5-turbo',
                                max_tokens: 100,
                                messages: [{ role: 'user', content: prompt }]
                            })
                        });
                        const data = await response.json();
                        return data.choices[0].message.content.trim();
                    }
                } catch (error) {
                    console.error('Hint API error:', error);
                    return null;
                }
            }
            
            async answerQuestion(question, card) {
                if (!this.enabled || !this.apiKey) return null;
                
                try {
                    const prompt = `The user is studying a flashcard: "${card.front}" = "${card.back}". 
                    They asked: "${question}". 
                    Provide a helpful, conversational answer (2-3 sentences) related to this flashcard content.`;
                    
                    if (this.apiProvider === 'anthropic') {
                        const response = await fetch('https://api.anthropic.com/v1/messages', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'x-api-key': this.apiKey,
                                'anthropic-version': '2023-06-01'
                            },
                            body: JSON.stringify({
                                model: 'claude-3-haiku-20240307',
                                max_tokens: 200,
                                messages: [{ role: 'user', content: prompt }]
                            })
                        });
                        const data = await response.json();
                        return data.content[0].text.trim();
                    } else {
                        const response = await fetch('https://api.openai.com/v1/chat/completions', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${this.apiKey}`
                            },
                            body: JSON.stringify({
                                model: 'gpt-3.5-turbo',
                                max_tokens: 200,
                                messages: [{ role: 'user', content: prompt }]
                            })
                        });
                        const data = await response.json();
                        return data.choices[0].message.content.trim();
                    }
                } catch (error) {
                    console.error('Question API error:', error);
                    return null;
                }
            }
        }
        
        const conversationalAgent = new ConversationalAgent();
        
        /**
         * Gemini Text-to-Speech (TTS) Agent
         * 
         * Uses Gemini 2.5 TTS models for high-quality, controllable speech synthesis.
         * Supports 30 different voices and 24 languages.
         * 
         * Documentation: https://ai.google.dev/gemini-api/docs/speech-generation
         */
        class GeminiTTS {
            constructor() {
                this.apiKey = localStorage.getItem('geminiApiKey') || '';
                this.enabled = localStorage.getItem('useGeminiTTS') === 'true';
                this.voiceName = localStorage.getItem('geminiTTSVoice') || 'Kore';
                this.model = 'gemini-2.5-flash-preview-tts';
                this.audioContext = null;
            }
            
            async initialize() {
                // Initialize audio context for playback - reuse VoiceEngine's context if available
                // This ensures we only create one AudioContext and it's created after user interaction
                if (!this.audioContext) {
                    // Try to reuse VoiceEngine's audio context if it exists
                    if (typeof voiceEngine !== 'undefined' && voiceEngine.audioContext) {
                        this.audioContext = voiceEngine.audioContext;
                    } else {
                        // Only create if we have user interaction (will be called from speak which requires user action)
                        try {
                            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            // Try to resume if suspended (may fail without user gesture)
                            if (this.audioContext.state === 'suspended') {
                                await this.audioContext.resume();
                            }
                        } catch (e) {
                            console.warn('AudioContext creation/resume failed:', e);
                            throw new Error('AudioContext requires user interaction');
                        }
                    }
                }
            }
            
            /**
             * Generate speech from text using Gemini TTS
             * @param {string} text - Text to convert to speech
             * @param {string} lang - Language code (BCP-47 format)
             * @param {string} voiceName - Optional voice name (overrides default)
             * @returns {Promise<ArrayBuffer>} PCM audio data
             */
            async generateSpeech(text, lang = 'en-US', voiceName = null) {
                if (!this.enabled || !this.apiKey) {
                    throw new Error('Gemini TTS not enabled or API key missing');
                }
                
                const voice = voiceName || this.voiceName;
                
                try {
                    const response = await fetch(
                        `https://generativelanguage.googleapis.com/v1beta/models/${this.model}:generateContent?key=${this.apiKey}`,
                        {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                contents: [{
                                    parts: [{ text: text }]
                                }],
                                generationConfig: {
                                    responseModalities: ['AUDIO'],
                                    speechConfig: {
                                        voiceConfig: {
                                            prebuiltVoiceConfig: {
                                                voiceName: voice
                                            }
                                        }
                                    }
                                }
                            })
                        }
                    );
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error?.message || 'TTS generation failed');
                    }
                    
                    const data = await response.json();
                    
                    // Extract audio data (base64 encoded PCM)
                    if (data.candidates && data.candidates[0]?.content?.parts?.[0]?.inlineData?.data) {
                        const base64Audio = data.candidates[0].content.parts[0].inlineData.data;
                        // Decode base64 to ArrayBuffer
                        const binaryString = atob(base64Audio);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        return bytes.buffer;
                    } else {
                        throw new Error('No audio data in response');
                    }
                } catch (error) {
                    console.error('Gemini TTS error:', error);
                    throw error;
                }
            }
            
            /**
             * Play PCM audio data (24kHz, 16-bit, mono)
             * @param {ArrayBuffer} pcmData - PCM audio data
             * @returns {Promise<void>}
             */
            async playAudio(pcmData) {
                await this.initialize();
                
                // Ensure audio context is resumed (requires user interaction)
                if (!this.audioContext) {
                    throw new Error('AudioContext not initialized');
                }
                
                if (this.audioContext.state === 'suspended') {
                    try {
                        await this.audioContext.resume();
                    } catch (e) {
                        console.warn('Failed to resume AudioContext:', e);
                        throw new Error('AudioContext requires user interaction');
                    }
                }
                
                // Convert 16-bit PCM to Float32Array
                const pcm16 = new Int16Array(pcmData);
                const float32 = new Float32Array(pcm16.length);
                for (let i = 0; i < pcm16.length; i++) {
                    float32[i] = pcm16[i] / 32768.0;
                }
                
                // Create AudioBuffer with 24kHz sample rate (Gemini TTS output rate)
                const sampleRate = 24000;
                const audioBuffer = this.audioContext.createBuffer(1, float32.length, sampleRate);
                audioBuffer.getChannelData(0).set(float32);
                
                // Play audio
                const source = this.audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(this.audioContext.destination);
                
                return new Promise((resolve) => {
                    source.onended = resolve;
                    source.start();
                });
            }
            
            /**
             * Speak text using Gemini TTS
             * @param {string} text - Text to speak
             * @param {string} lang - Language code
             * @param {string} voiceName - Optional voice name
             * @returns {Promise<void>}
             */
            async speak(text, lang = 'en-US', voiceName = null) {
                try {
                    const audioData = await this.generateSpeech(text, lang, voiceName);
                    await this.playAudio(audioData);
                } catch (error) {
                    console.error('Gemini TTS speak error:', error);
                    // If AudioContext error, fallback to browser TTS
                    if (error.message && error.message.includes('AudioContext')) {
                        throw new Error('AudioContext requires user interaction - falling back to browser TTS');
                    }
                    throw error;
                }
            }
        }
        
        const geminiTTS = new GeminiTTS();
        
        /**
         * OpenAI Realtime API Agent (using official Agents SDK)
         * 
         * Uses @openai/agents-realtime SDK for voice conversations with tool calling.
         * Supports WebRTC (browser) and WebSocket (server) transport layers.
         * 
         * Setup Instructions:
         * 1. Install: npm install @openai/agents-realtime zod@3
         * 2. Bundle with your build tool (webpack/vite/rollup) OR
         * 3. Load via CDN: Use script tag with type="module" and src="https://esm.sh/@openai/agents-realtime"
         * 
         * Ephemeral Token Generation (required for browser):
         * Generate on your backend server:
         * curl -X POST https://api.openai.com/v1/realtime/client_secrets \
         *   -H "Authorization: Bearer $OPENAI_API_KEY" \
         *   -H "Content-Type: application/json" \
         *   -d '{"session": {"type": "realtime", "model": "gpt-realtime"}}'
         * 
         * Documentation:
         * - Quickstart: https://openai.github.io/openai-agents-js/guides/voice-agents/quickstart/
         * - Realtime API: https://platform.openai.com/docs/guides/realtime
         * - WebRTC: https://platform.openai.com/docs/guides/realtime-webrtc
         */
        class OpenAIRealtimeAgent {
            constructor() {
                this.session = null;
                this.apiKey = localStorage.getItem('aiApiKey') || '';
                this.ephemeralKey = null; // Ephemeral token for browser (starts with "ek_")
                this.enabled = false;
                this.sdkLoaded = false;
                this.RealtimeAgent = null;
                this.RealtimeSession = null;
                this.tool = null;
            }
            
            async loadSDK() {
                if (this.sdkLoaded) return true;
                
                try {
                    // Try to load @openai/agents-realtime SDK dynamically
                    if (typeof window !== 'undefined' && window.RealtimeAgent) {
                        this.RealtimeAgent = window.RealtimeAgent;
                        this.RealtimeSession = window.RealtimeSession;
                        this.tool = window.tool;
                        this.sdkLoaded = true;
                        return true;
                    }
                    
                    // Try dynamic import (requires module bundler or CDN)
                    try {
                        const agents = await import('https://esm.sh/@openai/agents-realtime@latest');
                        this.RealtimeAgent = agents.RealtimeAgent;
                        this.RealtimeSession = agents.RealtimeSession;
                        this.tool = agents.tool;
                        this.sdkLoaded = true;
                        return true;
                    } catch (importError) {
                        console.warn('Could not load OpenAI Agents SDK via import:', importError);
                        showToast('OpenAI Agents SDK not loaded. Please include @openai/agents-realtime SDK.', 'warning');
                        return false;
                    }
                } catch (error) {
                    console.error('Failed to load OpenAI Agents SDK:', error);
                    showToast('Failed to load OpenAI Agents SDK. See console for details.', 'error');
                    return false;
                }
            }
            
            /**
             * Generate ephemeral token from backend (or use provided one)
             * In production, this should be done on your backend server
             */
            async generateEphemeralToken() {
                if (!this.apiKey) {
                    throw new Error('OpenAI API key not set');
                }
                
                // For browser use, ephemeral tokens should be generated on backend
                // For testing, we can try to generate one directly (not recommended for production)
                try {
                    const response = await fetch('https://api.openai.com/v1/realtime/client_secrets', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            session: {
                                type: 'realtime',
                                model: 'gpt-realtime'
                            }
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to generate ephemeral token');
                    }
                    
                    const data = await response.json();
                    return data.value; // Ephemeral token (starts with "ek_")
                } catch (error) {
                    console.error('Ephemeral token generation error:', error);
                    throw new Error('Failed to generate ephemeral token. Please generate on backend server.');
                }
            }
            
            async connect() {
                if (!this.apiKey) {
                    console.error('OpenAI API key not set');
                    showToast('Please set your OpenAI API key in Settings', 'error');
                    return false;
                }
                
                // Load SDK first
                const sdkReady = await this.loadSDK();
                if (!sdkReady) {
                    return false;
                }
                
                try {
                    // Generate or use ephemeral token
                    if (!this.ephemeralKey) {
                        this.ephemeralKey = await this.generateEphemeralToken();
                    }
                    
                    // Create agent with tools
                    const agent = new this.RealtimeAgent({
                        name: 'VoiceCards Tutor',
                        instructions: this.getSystemInstructions(),
                        tools: this.getToolDefinitions()
                    });
                    
                    // Create session
                    this.session = new this.RealtimeSession(agent, {
                        model: 'gpt-realtime'
                    });
                    
                    // Set up event listeners
                    this.setupEventListeners();
                    
                    // Connect using ephemeral token (WebRTC in browser)
                    await this.session.connect({
                        apiKey: this.ephemeralKey
                    });
                    
                    this.enabled = true;
                    return true;
                } catch (error) {
                    console.error('Failed to connect to OpenAI Realtime API:', error);
                    showToast('Failed to connect: ' + error.message, 'error');
                    return false;
                }
            }
            
            setupEventListeners() {
                if (!this.session) return;
                
                // Handle tool calls
                this.session.on('tool_call', (event) => {
                    this.processToolCall(event);
                });
                
                // Handle session events
                this.session.on('response_completed', () => {
                    console.log('Response completed');
                });
                
                this.session.on('error', (error) => {
                    console.error('Realtime session error:', error);
                    showToast('Realtime API error: ' + error.message, 'error');
                });
            }
            
            getSystemInstructions() {
                return `You are a helpful language learning tutor for VoiceCards, a hands-free flashcard app.

Current session context:
- Deck: ${AppState.session?.deck || 'none'}
- Cards studied: ${AppState.session?.cardsStudied || 0}
- Current card: ${AppState.session?.currentCard ? `${AppState.session.currentCard.front} = ${AppState.session.currentCard.back}` : 'none'}

Your role:
- Provide encouraging, conversational responses
- Use tools to interact with the flashcard system
- Give hints when asked (without revealing answers)
- Explain concepts naturally
- Keep responses brief and conversational

When user answers correctly, use rate_card tool with quality 5.
When user answers incorrectly, use rate_card tool with quality 1.
When user asks for help, use get_hint tool.
When user wants to see answer, use show_answer tool.
When user wants to repeat, use repeat_card tool.`;
            }
            
            getToolDefinitions() {
                if (!this.tool) return [];
                
                return [
                    this.tool({
                        type: 'function',
                        function: {
                            name: 'rate_card',
                            description: 'Rate the current flashcard based on how well the user knows it',
                            parameters: {
                                type: 'object',
                                properties: {
                                    quality: {
                                        type: 'integer',
                                        description: 'Rating from 1-5: 1=Hard/Forgot, 3=Good/Okay, 5=Easy/Knew it',
                                        enum: [1, 2, 3, 4, 5]
                                    }
                                },
                                required: ['quality']
                            }
                        }
                    }),
                    this.tool({
                        type: 'function',
                        function: {
                            name: 'show_answer',
                            description: 'Show/reveal the answer to the current flashcard',
                            parameters: {
                                type: 'object',
                                properties: {},
                                required: []
                            }
                        }
                    }),
                    this.tool({
                        type: 'function',
                        function: {
                            name: 'repeat_card',
                            description: 'Repeat the current flashcard question',
                            parameters: {
                                type: 'object',
                                properties: {},
                                required: []
                            }
                        }
                    }),
                    this.tool({
                        type: 'function',
                        function: {
                            name: 'get_hint',
                            description: 'Get a helpful hint for the current flashcard without revealing the answer',
                            parameters: {
                                type: 'object',
                                properties: {},
                                required: []
                            }
                        }
                    }),
                    this.tool({
                        type: 'function',
                        function: {
                            name: 'next_card',
                            description: 'Move to the next card (rates current as "good" and advances)',
                            parameters: {
                                type: 'object',
                                properties: {},
                                required: []
                            }
                        }
                    }),
                    this.tool({
                        type: 'function',
                        function: {
                            name: 'end_session',
                            description: 'End the current study session',
                            parameters: {
                                type: 'object',
                                properties: {},
                                required: []
                            }
                        }
                    })
                ];
            }
            
            processToolCall(event) {
                const { name, arguments: args } = event;
                
                console.log('OpenAI tool call:', name, args);
                
                switch (name) {
                    case 'rate_card':
                        rateCard(args.quality || 3);
                        break;
                    case 'show_answer':
                        showCard();
                        break;
                    case 'repeat_card':
                        voiceEngine.repeatCard();
                        break;
                    case 'get_hint':
                        voiceEngine.getHint();
                        break;
                    case 'next_card':
                        rateCard(3);
                        break;
                    case 'end_session':
                        endSession();
                        this.disconnect();
                        break;
                }
            }
            
            disconnect() {
                if (this.session) {
                    try {
                        this.session.disconnect();
                    } catch (error) {
                        console.error('Error disconnecting session:', error);
                    }
                    this.session = null;
                }
                this.enabled = false;
                this.ephemeralKey = null; // Clear ephemeral token
            }
        }
        
        const openAIRealtimeAgent = new OpenAIRealtimeAgent();
        
        // Google Gemini Live API with WebSocket and Tool Control
        /**
         * Gemini Live API Agent
         * 
         * Implements Google's Gemini Live API for real-time voice conversations.
         * Requires @google/genai SDK to be loaded.
         * 
         * Setup Instructions:
         * 1. Install: npm install @google/genai
         * 2. Bundle with your build tool (webpack/vite/rollup) OR
         * 3. Load via CDN: Use script tag with type="module" and src="https://esm.sh/@google/genai"
         * 4. Or expose globally: window.GoogleGenAI = GoogleGenAI; window.Modality = Modality;
         * 
         * For production, consider using ephemeral tokens for security:
         * https://ai.google.dev/gemini-api/docs/ephemeral-tokens
         * 
         * Documentation:
         * - Live API Guide: https://ai.google.dev/gemini-api/docs/live-guide
         * - Tool Use: https://ai.google.dev/gemini-api/docs/live-tools
         * - Session Management: https://ai.google.dev/gemini-api/docs/live-session
         */
        class GeminiLiveAgent {
            constructor() {
                this.session = null;
                this.apiKey = localStorage.getItem('geminiApiKey') || '';
                this.enabled = false;
                this.audioQueue = [];
                this.isPlaying = false;
                this.audioContext = null;
                this.stream = null;
                this.mediaRecorder = null;
                this.audioChunks = [];
                this.sdkLoaded = false;
                this.GoogleGenAI = null;
                this.Modality = null;
            }
            
            async loadSDK() {
                if (this.sdkLoaded) return true;
                
                try {
                    // Try to load @google/genai SDK dynamically
                    // Note: In production, you should bundle this or use a CDN
                    // For now, we'll check if it's available globally or try to import
                    if (typeof window !== 'undefined' && window.GoogleGenAI) {
                        this.GoogleGenAI = window.GoogleGenAI;
                        this.Modality = window.Modality;
                        this.sdkLoaded = true;
                        return true;
                    }
                    
                    // Try dynamic import (requires module bundler or CDN)
                    try {
                        const genai = await import('https://esm.sh/@google/genai@latest');
                        this.GoogleGenAI = genai.GoogleGenAI;
                        this.Modality = genai.Modality;
                        this.sdkLoaded = true;
                        return true;
                    } catch (importError) {
                        console.warn('Could not load SDK via import, using fallback:', importError);
                        // Fallback: Show instructions to user
                        showToast('Gemini SDK not loaded. Please include @google/genai SDK.', 'warning');
                        return false;
                    }
                } catch (error) {
                    console.error('Failed to load Gemini SDK:', error);
                    showToast('Failed to load Gemini SDK. See console for details.', 'error');
                    return false;
                }
            }
            
            async connect() {
                if (!this.apiKey) {
                    console.error('Gemini API key not set');
                    showToast('Please set your Gemini API key in Settings', 'error');
                    return false;
                }
                
                // Load SDK first
                const sdkReady = await this.loadSDK();
                if (!sdkReady) {
                    return false;
                }
                
                try {
                    const model = 'gemini-2.5-flash-native-audio-preview-09-2025';
                    const config = {
                        responseModalities: [this.Modality.AUDIO],
                        outputAudioTranscription: {}, // Enable transcription
                        systemInstruction: {
                            parts: [{ text: this.getSystemInstructions() }]
                        },
                        tools: this.getToolDefinitions()
                    };
                    
                    // Initialize audio context
                    await voiceEngine.ensureAudioContext();
                    this.audioContext = voiceEngine.audioContext;
                    
                    // Create GoogleGenAI client
                    const ai = new this.GoogleGenAI({ apiKey: this.apiKey });
                    
                    // Connect to Live API session
                    this.session = await ai.live.connect({
                        model: model,
                        config: config,
                        callbacks: {
                            onopen: () => {
                                console.log('Gemini Live API session opened');
                                this.enabled = true;
                                this.startMicrophone();
                            },
                            onmessage: (message) => {
                                this.handleMessage(message);
                            },
                            onerror: (error) => {
                                console.error('Gemini Live API error:', error);
                                showToast('Gemini Live API error: ' + error.message, 'error');
                            },
                            onclose: (event) => {
                                console.log('Gemini Live API session closed:', event.reason);
                                this.enabled = false;
                                this.stopMicrophone();
                            }
                        }
                    });
                    
                    return true;
                } catch (error) {
                    console.error('Failed to connect to Gemini Live API:', error);
                    showToast('Failed to connect to Gemini Live API: ' + error.message, 'error');
                    return false;
                }
            }
            
            async startMicrophone() {
                if (!this.session || !this.enabled) return;
                
                try {
                    this.stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            sampleRate: 16000, // Native input rate for Gemini Live API
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        } 
                    });
                    
                    // Process audio stream using AudioWorklet or ScriptProcessor
                    this.processAudioStream();
                } catch (error) {
                    console.error('Microphone access error:', error);
                    showToast('Microphone access denied', 'error');
                }
            }
            
            stopMicrophone() {
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }
                if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
                    this.mediaRecorder.stop();
                    this.mediaRecorder = null;
                }
            }
            
            processAudioStream() {
                if (!this.stream || !this.audioContext || !this.session) return;
                
                // Use AudioWorklet if available, otherwise fall back to ScriptProcessor
                const source = this.audioContext.createMediaStreamSource(this.stream);
                
                // Create a processor to convert to 16-bit PCM
                const bufferSize = 4096;
                const processor = this.audioContext.createScriptProcessor(bufferSize, 1, 1);
                
                processor.onaudioprocess = (e) => {
                    if (!this.enabled || !this.session) return;
                    
                    const inputData = e.inputBuffer.getChannelData(0);
                    
                    // Convert Float32 to 16-bit PCM (little-endian)
                    const pcm16 = new Int16Array(inputData.length);
                    for (let i = 0; i < inputData.length; i++) {
                        // Clamp to [-1, 1] and convert to 16-bit integer
                        const sample = Math.max(-1, Math.min(1, inputData[i]));
                        pcm16[i] = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                    }
                    
                    // Convert to base64 for sending
                    const uint8Array = new Uint8Array(pcm16.buffer);
                    const base64Audio = btoa(String.fromCharCode(...uint8Array));
                    
                    // Send audio chunk to Gemini Live API
                    // Format: audio/pcm;rate=16000 (as per documentation)
                    this.session.sendRealtimeInput({
                        audio: {
                            data: base64Audio,
                            mimeType: 'audio/pcm;rate=16000'
                        }
                    });
                };
                
                source.connect(processor);
                processor.connect(this.audioContext.destination);
            }
            
            getSystemInstructions() {
                return `You are a helpful language learning tutor for VoiceCards, a hands-free flashcard app.

Current session context:
- Deck: ${AppState.session?.deck || 'none'}
- Cards studied: ${AppState.session?.cardsStudied || 0}
- Current card: ${AppState.session?.currentCard ? `${AppState.session.currentCard.front} = ${AppState.session.currentCard.back}` : 'none'}

Your role:
- Provide encouraging, conversational responses
- Use tools to interact with the flashcard system
- Give hints when asked (without revealing answers)
- Explain concepts naturally
- Keep responses brief and conversational

When user answers correctly, use rate_card tool with quality 5.
When user answers incorrectly, use rate_card tool with quality 1.
When user asks for help, use get_hint tool.
When user wants to see answer, use show_answer tool.
When user wants to repeat, use repeat_card tool.`;
            }
            
            getToolDefinitions() {
                return [{
                    functionDeclarations: [
                        {
                            name: 'rate_card',
                            description: 'Rate the current flashcard based on how well the user knows it',
                            parameters: {
                                type: 'object',
                                properties: {
                                    quality: {
                                        type: 'integer',
                                        description: 'Rating from 1-5: 1=Hard/Forgot, 3=Good/Okay, 5=Easy/Knew it',
                                        enum: [1, 2, 3, 4, 5]
                                    }
                                },
                                required: ['quality']
                            }
                        },
                        {
                            name: 'show_answer',
                            description: 'Show/reveal the answer to the current flashcard',
                            parameters: {
                                type: 'object',
                                properties: {},
                                required: []
                            }
                        },
                        {
                            name: 'repeat_card',
                            description: 'Repeat the current flashcard question',
                            parameters: {
                                type: 'object',
                                properties: {},
                                required: []
                            }
                        },
                        {
                            name: 'get_hint',
                            description: 'Get a helpful hint for the current flashcard without revealing the answer',
                            parameters: {
                                type: 'object',
                                properties: {},
                                required: []
                            }
                        },
                        {
                            name: 'next_card',
                            description: 'Move to the next card (rates current as "good" and advances)',
                            parameters: {
                                type: 'object',
                                properties: {},
                                required: []
                            }
                        },
                        {
                            name: 'end_session',
                            description: 'End the current study session',
                            parameters: {
                                type: 'object',
                                properties: {},
                                required: []
                            }
                        }
                    ]
                }];
            }
            
            handleMessage(message) {
                // Handle messages from Gemini Live API session
                // Per documentation: messages can contain serverContent with modelTurn, outputTranscription, etc.
                
                if (message.serverContent) {
                    const serverContent = message.serverContent;
                    
                    // Handle model turn (audio/text response)
                    if (serverContent.modelTurn) {
                        const modelTurn = serverContent.modelTurn;
                        
                        if (modelTurn.parts) {
                            for (const part of modelTurn.parts) {
                                // Handle function calls (tool use)
                                if (part.functionCall) {
                                    this.processToolCall(part.functionCall);
                                }
                                
                                // Handle audio response (24kHz PCM output)
                                if (part.inlineData && part.inlineData.mimeType && part.inlineData.mimeType.includes('audio')) {
                                    this.handleAudioResponse(part.inlineData.data);
                                }
                                
                                // Handle text response
                                if (part.text) {
                                    voiceEngine.speak(part.text, 'en-US', false);
                                }
                            }
                        }
                    }
                    
                    // Handle output transcription (if enabled)
                    if (serverContent.outputTranscription) {
                        const transcript = serverContent.outputTranscription.text;
                        console.log('Gemini output transcript:', transcript);
                        // Optionally display or log the transcription
                    }
                    
                    // Handle input transcription
                    if (serverContent.inputTranscription) {
                        const transcript = serverContent.inputTranscription.text;
                        console.log('User input transcript:', transcript);
                    }
                    
                    // Handle tool calls in response
                    if (serverContent.toolCall) {
                        this.processToolCall(serverContent.toolCall);
                    }
                }
            }
            
            processToolCall(toolCall) {
                // Process tool/function calls from Gemini
                if (!toolCall || !toolCall.name) return;
                
                const functionName = toolCall.name;
                const args = toolCall.args || {};
                
                console.log('Gemini tool call:', functionName, args);
                
                // Execute the tool call
                this.executeToolCall({
                    name: functionName,
                    args: args
                });
            }
            
            handleAudioResponse(base64Audio) {
                // Handle audio response from Gemini Live API
                // Audio format: 24kHz, 16-bit PCM, little-endian (per documentation)
                this.audioQueue.push(base64Audio);
                if (!this.isPlaying) {
                    this.playAudioQueue();
                }
            }
            
            async playAudioQueue() {
                if (this.audioQueue.length === 0) {
                    this.isPlaying = false;
                    return;
                }
                
                this.isPlaying = true;
                const audioChunk = this.audioQueue.shift();
                
                try {
                    await voiceEngine.ensureAudioContext();
                    const audioContext = voiceEngine.audioContext;
                    
                    if (!audioContext) {
                        setTimeout(() => this.playAudioQueue(), 50);
                        return;
                    }
                    
                    // Decode base64 audio (24kHz PCM from Gemini Live API)
                    const audioBytes = Uint8Array.from(atob(audioChunk), c => c.charCodeAt(0));
                    
                    // Convert 16-bit PCM bytes to Float32Array for Web Audio API
                    const pcm16 = new Int16Array(audioBytes.buffer);
                    const float32 = new Float32Array(pcm16.length);
                    for (let i = 0; i < pcm16.length; i++) {
                        float32[i] = pcm16[i] / 32768.0;
                    }
                    
                    // Create AudioBuffer with 24kHz sample rate (Gemini output rate)
                    const sampleRate = 24000;
                    const audioBuffer = audioContext.createBuffer(1, float32.length, sampleRate);
                    audioBuffer.getChannelData(0).set(float32);
                    
                    // Play audio
                    const source = audioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(audioContext.destination);
                    source.onended = () => {
                        setTimeout(() => this.playAudioQueue(), 50);
                    };
                    source.start();
                } catch (error) {
                    console.error('Audio playback error:', error);
                    setTimeout(() => this.playAudioQueue(), 50);
                }
            }
            
            async executeToolCall(functionCall) {
                const { name, args } = functionCall;
                
                switch (name) {
                    case 'rate_card':
                        await rateCard(args.quality || 3);
                        break;
                    case 'show_answer':
                        await showCard();
                        break;
                    case 'repeat_card':
                        await voiceEngine.repeatCard();
                        break;
                    case 'get_hint':
                        await voiceEngine.getHint();
                        break;
                    case 'next_card':
                        await rateCard(3);
                        break;
                    case 'end_session':
                        await endSession();
                        this.disconnect();
                        break;
                }
            }
            
            disconnect() {
                if (this.session) {
                    try {
                        this.session.close();
                    } catch (error) {
                        console.error('Error closing Gemini Live session:', error);
                    }
                    this.session = null;
                }
                this.enabled = false;
                this.stopMicrophone();
            }
        }
        
        const geminiLiveAgent = new GeminiLiveAgent();
        
        // Spaced Repetition Algorithm
        class SpacedRepetition {
            static calculateInterval(card, quality) {
                // SM-2 Algorithm
                if (quality < 0) quality = 0;
                if (quality > 5) quality = 5;
                
                if (!card.interval) card.interval = 1;
                if (!card.easeFactor) card.easeFactor = 2.5;
                
                if (quality >= 3) {
                    if (card.repetitions === 0) {
                        card.interval = 1;
                    } else if (card.repetitions === 1) {
                        card.interval = 6;
                    } else {
                        card.interval = Math.round(card.interval * card.easeFactor);
                    }
                    
                    card.easeFactor = card.easeFactor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
                    card.repetitions = (card.repetitions || 0) + 1;
                } else {
                    card.repetitions = 0;
                    card.interval = 1;
                    card.easeFactor = Math.max(1.3, card.easeFactor - 0.2);
                }
                
                card.easeFactor = Math.max(1.3, card.easeFactor);
                card.nextReview = new Date(Date.now() + card.interval * 86400000); // days to ms
                
                return card;
            }
        }
        
        // Core Functions
        async function initializeApp() {
            // Hide loading screen IMMEDIATELY (no delay)
            const loadingScreen = document.getElementById('loadingScreen');
            if (loadingScreen) {
                loadingScreen.style.display = 'none';
            }
            
            // Initialize database
            await db.init();
            
            // Check authentication
            if (api.token) {
                try {
                    const userData = await api.getCurrentUser();
                    AppState.user = {
                        ...AppState.user,
                        id: userData.user.id,
                        email: userData.user.email,
                        name: userData.user.name || userData.user.email.split('@')[0],
                        authenticated: true
                    };
                    await loadUserData();
                } catch (error) {
                    console.warn('Auth check failed:', error);
                    api.logout();
                }
            }
            
            // Show login if not authenticated
            if (!AppState.user.authenticated) {
                showLoginModal();
            }
            
            // Show UI immediately
            const hasOnboarded = localStorage.getItem('hasOnboarded');
            const voiceOnboarding = localStorage.getItem('voiceOnboarding') === 'true';
            
            if (hasOnboarded) {
                showSection('study');
            } else {
                showSection('onboarding');
            }
            
            // Initialize in background (non-blocking)
            (async () => {
                try {
                    // Load saved settings
                    loadSettings();
                    
                    // Check online status
                    updateOnlineStatus();
                    window.addEventListener('online', updateOnlineStatus);
                    window.addEventListener('offline', updateOnlineStatus);
                    
                    // Keep audio context alive for background audio (only after user interaction)
                    if (document.getElementById('backgroundAudioEnabled')?.checked !== false) {
                        // Initialize audio context on first user interaction
                        const initAudioOnInteraction = async () => {
                            await voiceEngine.ensureAudioContext();
                            // Remove listener after first interaction
                            document.removeEventListener('click', initAudioOnInteraction);
                            document.removeEventListener('touchstart', initAudioOnInteraction);
                        };
                        
                        document.addEventListener('click', initAudioOnInteraction, { once: true });
                        document.addEventListener('touchstart', initAudioOnInteraction, { once: true });
                        
                        setInterval(() => {
                            if (voiceEngine.audioContext) {
                                voiceEngine.keepAudioAlive();
                            }
                        }, 5000); // Check every 5 seconds
                        
                        // Handle page visibility changes (screen lock/unlock)
                        document.addEventListener('visibilitychange', () => {
                            if (!document.hidden && voiceEngine.audioContext) {
                                // Page became visible, resume audio context
                                voiceEngine.keepAudioAlive();
                            }
                        });
                        
                        // Handle page focus/blur
                        window.addEventListener('blur', () => {
                            // Page lost focus but keep audio alive
                            if (voiceEngine.audioContext) {
                                voiceEngine.keepAudioAlive();
                            }
                        });
                    }
                    
                    // Initialize sample decks (non-blocking)
                    initializeSampleDecks().then(() => {
                        // Render decks list after loading
                        renderDecks();
                    });
                    
                    // Start session timer
                    setInterval(updateSessionTimer, 1000);
                    
                    // Voice onboarding after everything loads
                    if (hasOnboarded && voiceOnboarding) {
                        await startVoiceOnboarding();
                    }
                } catch (error) {
                    console.error('Initialization error:', error);
                    showToast('Some features may not be available', 'error');
                }
            })();
        }
        
        async function startVoiceOnboarding() {
            showSection('study');
            
            // Wait a moment for UI to render
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await voiceEngine.speak('Welcome to VoiceCards! I\'ll guide you through a hands-free learning experience.', 'en-US', true);
            await voiceEngine.speakWithDelay('First, let me check if you have any decks set up.', 1000);
            
            const deckCount = Object.keys(AppState.decks).length;
            if (deckCount === 0) {
                await voiceEngine.speak('You don\'t have any decks yet. Let me create a sample deck for you.', 'en-US', true);
                await voiceEngine.speakWithDelay('To start studying, say "Start session" or click the Start button.', 1000);
            } else {
                await voiceEngine.speak(`You have ${deckCount} deck${deckCount > 1 ? 's' : ''} ready.`, 'en-US', true);
                await voiceEngine.speakWithDelay('To start a hands-free session, click the Hands-Free button, or say "Start session" after I finish.', 1000);
            }
            
            await voiceEngine.speak('Here\'s how hands-free mode works:', 'en-US', true);
            await voiceEngine.speakWithDelay('Cards will automatically play. Say your answer, or use commands like "Easy", "Good", or "Hard" to rate cards.', 1000);
            await voiceEngine.speakWithDelay('Say "Repeat" to hear the question again, "Show" to see the answer, or "Stop" to end the session.', 1000);
            await voiceEngine.speak('Ready to start learning? Say "Start session" or click Start to begin!', 'en-US', true);
            
            // Enable voice commands for starting session
            voiceEngine.startListening();
            voiceEngine.wakeWordDetected = true; // Allow commands immediately
        }
        
        async function initializeSampleDecks() {
            // Check if cards already exist in DB
            const existingCards = await db.getAllCards();
            
            if (existingCards.length === 0) {
                // Only initialize if DB is empty
                AppState.decks = {
                    japanese: [
                        { id: 1, front: '„Åä„ÅØ„Çà„ÅÜ', back: 'Good morning', pronunciation: 'ohayou', deck: 'japanese', nextReview: null, repetitions: 0, easeFactor: 2.5, interval: 1 },
                        { id: 2, front: '„ÅÇ„Çä„Åå„Å®„ÅÜ', back: 'Thank you', pronunciation: 'arigatou', deck: 'japanese', nextReview: null, repetitions: 0, easeFactor: 2.5, interval: 1 },
                        { id: 3, front: 'Êó•Êú¨', back: 'Japan', pronunciation: 'nihon', deck: 'japanese', nextReview: null, repetitions: 0, easeFactor: 2.5, interval: 1 },
                        { id: 4, front: 'Ê∞¥', back: 'Water', pronunciation: 'mizu', deck: 'japanese', nextReview: null, repetitions: 0, easeFactor: 2.5, interval: 1 },
                        { id: 5, front: 'È£ü„Åπ„Çã', back: 'To eat', pronunciation: 'taberu', deck: 'japanese', nextReview: null, repetitions: 0, easeFactor: 2.5, interval: 1 }
                    ],
                    medical: [
                        { id: 6, front: 'Tachycardia', back: 'Rapid heart rate > 100 bpm', deck: 'medical', nextReview: null, repetitions: 0, easeFactor: 2.5, interval: 1 },
                        { id: 7, front: 'Bradycardia', back: 'Slow heart rate < 60 bpm', deck: 'medical', nextReview: null, repetitions: 0, easeFactor: 2.5, interval: 1 },
                        { id: 8, front: 'Hypertension', back: 'High blood pressure', deck: 'medical', nextReview: null, repetitions: 0, easeFactor: 2.5, interval: 1 }
                    ],
                    spanish: [
                        { id: 9, front: 'Hola', back: 'Hello', pronunciation: 'OH-lah', deck: 'spanish', nextReview: null, repetitions: 0, easeFactor: 2.5, interval: 1 },
                        { id: 10, front: 'Gracias', back: 'Thank you', pronunciation: 'GRAH-see-ahs', deck: 'spanish', nextReview: null, repetitions: 0, easeFactor: 2.5, interval: 1 }
                    ]
                };
                
                // Save to IndexedDB
                for (const card of Object.values(AppState.decks).flat()) {
                    await db.saveCard(card);
                }
            } else {
                // Load decks from DB
                const allCards = await db.getAllCards();
                AppState.decks = {};
                allCards.forEach(card => {
                    if (!AppState.decks[card.deck]) {
                        AppState.decks[card.deck] = [];
                    }
                    AppState.decks[card.deck].push(card);
                });
            }
            
            // Update deck counts in sidebar
            updateDeckCounts();
        }
        
        async function updateDeckCounts() {
            const now = new Date();
            for (const deckName in AppState.decks) {
                const cards = AppState.decks[deckName];
                const dueCount = cards.filter(card => {
                    if (!card.nextReview) return true;
                    return new Date(card.nextReview) <= now;
                }).length;
                
                // Update sidebar deck count
                const deckItems = document.querySelectorAll('.deck-item');
                deckItems.forEach(item => {
                    if (item.textContent.includes(deckName.charAt(0).toUpperCase() + deckName.slice(1))) {
                        const countEl = item.querySelector('.deck-count');
                        if (countEl) {
                            countEl.textContent = `${dueCount} due`;
                        }
                    }
                });
            }
        }
        
        function showSection(section) {
            document.querySelectorAll('.app-container').forEach(container => {
                container.classList.remove('active');
            });
            
            document.getElementById(section).classList.add('active');
            
            // Update top nav (desktop)
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Update bottom nav (mobile)
            document.querySelectorAll('.bottom-nav-item').forEach(item => {
                item.classList.remove('active');
            });
            
            const navMap = {
                'study': 0,
                'decks': 1,
                'analytics': 2,
                'settings': 3
            };
            
            if (navMap[section] !== undefined) {
                // Update desktop nav
                const desktopNavItems = document.querySelectorAll('.nav-item');
                if (desktopNavItems[navMap[section]]) {
                    desktopNavItems[navMap[section]].classList.add('active');
                }
                
                // Update mobile bottom nav
                const mobileNavItems = document.querySelectorAll('.bottom-nav-item');
                if (mobileNavItems[navMap[section]]) {
                    mobileNavItems[navMap[section]].classList.add('active');
                }
            }
            
            // Render decks if on decks section
            if (section === 'decks') {
                renderDecks();
            }
        }
        
        async function startSession(deckName) {
            if (!deckName) {
                deckName = 'japanese'; // Default deck
            }
            
            // Stop any existing hands-free mode
            if (voiceEngine.handsFreeMode) {
                voiceEngine.stopHandsFreeMode();
            }
            
            // Load cards from IndexedDB
            const cards = await db.getCards(deckName);
            
            // Filter due cards (cards that need review)
            const now = new Date();
            const dueCards = cards.filter(card => {
                if (!card.nextReview) return true; // New cards
                return new Date(card.nextReview) <= now;
            });
            
            if (dueCards.length === 0) {
                showToast('No cards due for review! Great job! üéâ', 'info');
                if (voiceEngine.handsFreeMode) {
                    voiceEngine.speak('No cards due for review. Great job!', 'en-US', true);
                }
                return;
            }
            
            AppState.session = {
                active: true,
                deck: deckName,
                currentCard: null,
                queue: [...dueCards],
                startTime: Date.now(),
                cardsStudied: 0,
                correctAnswers: 0,
                autoAdvance: false,
                autoPlay: true
            };
            
            // Shuffle queue
            AppState.session.queue.sort(() => Math.random() - 0.5);
            
            showToast(`Starting ${deckName} session - ${dueCards.length} cards due`, 'info');
            
            // Show first card
            await nextCard();
            
            // Update UI
            document.getElementById('startBtn').style.display = 'none';
            document.getElementById('handsFreeStatus').style.display = 'none';
        }
        
        async function nextCard() {
            if (AppState.session.queue.length === 0) {
                await endSession();
                return;
            }
            
            // In hands-free mode, announce the transition
            if (voiceEngine.handsFreeMode) {
                await voiceEngine.speakWithDelay('Next card', 'en-US', false);
            }
            
            AppState.session.currentCard = AppState.session.queue.shift();
            await displayCard(AppState.session.currentCard);
            
            // Update progress
            const totalCards = AppState.session.cardsStudied + AppState.session.queue.length + 1;
            const progress = ((AppState.session.cardsStudied / totalCards) * 100);
            document.getElementById('progressFill').style.width = progress + '%';
        }
        
        async function displayCard(card) {
            // Reset flip
            document.getElementById('cardInner').classList.remove('flipped');
            
            // Update content
            document.getElementById('cardFront').textContent = card.front;
            document.getElementById('cardHint').textContent = card.pronunciation || 'Think carefully...';
            document.getElementById('cardBack').textContent = card.back;
            document.getElementById('cardDetails').textContent = card.details || '';
            
            // Auto-play card (ALWAYS in hands-free mode, or if setting enabled)
            const shouldAutoPlay = voiceEngine.handsFreeMode || document.getElementById('autoPronounce')?.checked || AppState.session.autoPlay;
            if (shouldAutoPlay && AppState.session.active) {
                const lang = AppState.session.deck === 'japanese' ? 'ja-JP' : 
                            AppState.session.deck === 'spanish' ? 'es-ES' : 'en-US';
                
                // In hands-free mode, ALWAYS speak both sides
                if (voiceEngine.handsFreeMode) {
                    // Speak the question (front side)
                    await voiceEngine.speak(card.front, lang, true);
                    
                    // Speak pronunciation if available
                    if (card.pronunciation) {
                        await voiceEngine.speakWithDelay(`Pronunciation: ${card.pronunciation}`, 400);
                    }
                    
                    // Give instructions
                    await voiceEngine.speakWithDelay('Say your answer, or say "show" to hear the answer', 500);
                } else {
                    // Regular mode: just speak the question
                    await voiceEngine.speak(card.front, lang, true);
                    if (card.pronunciation) {
                        await voiceEngine.speakWithDelay(`Pronunciation: ${card.pronunciation}`, 300);
                    }
                }
            }
        }
        
        async function showCard() {
            const cardInner = document.getElementById('cardInner');
            if (!cardInner.classList.contains('flipped')) {
                cardInner.classList.add('flipped');
                
                // ALWAYS speak the answer when showing card (especially in hands-free mode)
                if (AppState.session.currentCard) {
                    const card = AppState.session.currentCard;
                    const lang = AppState.session.deck === 'japanese' ? 'ja-JP' : 
                                AppState.session.deck === 'spanish' ? 'es-ES' : 'en-US';
                    
                    if (voiceEngine.handsFreeMode) {
                        // In hands-free mode, speak clearly
                        await voiceEngine.speak('The answer is', 'en-US', true);
                        await voiceEngine.speakWithDelay(card.back, lang, false);
                    } else {
                        // Regular mode: just speak the answer
                        await voiceEngine.speak(card.back, lang, true);
                    }
                }
            }
        }
        
        async function rateCard(quality) {
            if (!AppState.session.active || !AppState.session.currentCard) return;
            
            const card = AppState.session.currentCard;
            const lang = AppState.session.deck === 'japanese' ? 'ja-JP' : 
                        AppState.session.deck === 'spanish' ? 'es-ES' : 'en-US';
            
            // In hands-free mode, ALWAYS speak the answer first (both sides)
            if (voiceEngine.handsFreeMode) {
                // Show answer if not already shown
                if (!document.getElementById('cardInner').classList.contains('flipped')) {
                    document.getElementById('cardInner').classList.add('flipped');
                }
                
                // Speak the answer (back side)
                await voiceEngine.speak(card.back, lang, true);
                
                // Speak assessment based on quality
                const qualityText = quality >= 4 ? 'Marked as easy' : 
                                   quality >= 3 ? 'Marked as good' : 
                                   'Marked as hard';
                await voiceEngine.speakWithDelay(qualityText, 500);
            } else {
                // Show answer if not already shown
                if (!document.getElementById('cardInner').classList.contains('flipped')) {
                    showCard();
                }
            }
            
            // Update spaced repetition
            const updatedCard = SpacedRepetition.calculateInterval(AppState.session.currentCard, quality);
            db.saveCard(updatedCard);
            
            // Update card in decks array
            const deckCards = AppState.decks[AppState.session.deck];
            const cardIndex = deckCards.findIndex(c => c.id === updatedCard.id);
            if (cardIndex !== -1) {
                deckCards[cardIndex] = updatedCard;
            }
            
            // Update session stats
            AppState.session.cardsStudied++;
            if (quality >= 3) {
                AppState.session.correctAnswers++;
            }
            
            updateStats();
            
            // Audio feedback in hands-free mode - announce next card
            if (voiceEngine.handsFreeMode) {
                const remaining = AppState.session.queue.length;
                if (remaining > 0) {
                    await voiceEngine.speakWithDelay(`Moving to next card. ${remaining} card${remaining > 1 ? 's' : ''} remaining.`, 800);
                } else {
                    await voiceEngine.speakWithDelay('That was the last card!', 800);
                }
            }
            
            // Auto-advance: automatically go to next card after a delay
            const delay = voiceEngine.handsFreeMode ? 1200 : 800;
            setTimeout(() => nextCard(), delay);
        }
        
        async function endSession() {
            if (!AppState.session.active) return;
            
            const duration = Math.floor((Date.now() - AppState.session.startTime) / 1000);
            const accuracy = AppState.session.cardsStudied > 0 
                ? Math.round((AppState.session.correctAnswers / AppState.session.cardsStudied) * 100) 
                : 0;
            
            // Stop hands-free mode
            if (voiceEngine.handsFreeMode) {
                voiceEngine.stopHandsFreeMode();
                document.getElementById('handsFreeStatus').style.display = 'none';
            }
            
            // Save session to database
            db.saveSession({
                date: new Date(),
                deck: AppState.session.deck,
                cardsStudied: AppState.session.cardsStudied,
                correctAnswers: AppState.session.correctAnswers,
                duration: duration,
                accuracy: accuracy
            });
            
            // Audio summary in hands-free mode
            const summary = `Session complete! You studied ${AppState.session.cardsStudied} cards with ${accuracy} percent accuracy.`;
            if (voiceEngine.handsFreeMode) {
                await voiceEngine.speak(summary, 'en-US', true);
            } else {
                showToast(`Session complete! ${AppState.session.cardsStudied} cards, ${accuracy}% accuracy`, 'success');
            }
            
            // Reset UI
            document.getElementById('cardFront').textContent = 'Session Complete! üéâ';
            document.getElementById('cardHint').textContent = `You studied ${AppState.session.cardsStudied} cards`;
            document.getElementById('startBtn').style.display = 'block';
            document.getElementById('handsFreeBtn').innerHTML = '<span>üéôÔ∏è</span> Hands-Free';
            document.getElementById('handsFreeBtn').style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
            
            AppState.session.active = false;
        }
        
        function updateStats() {
            document.getElementById('sessionCards').textContent = AppState.session.cardsStudied;
            document.getElementById('todayCards').textContent = AppState.session.cardsStudied;
            
            const accuracy = AppState.session.cardsStudied > 0 
                ? Math.round((AppState.session.correctAnswers / AppState.session.cardsStudied) * 100) 
                : 0;
            document.getElementById('sessionAccuracy').textContent = accuracy + '%';
            document.getElementById('accuracy').textContent = accuracy + '%';
        }
        
        function updateSessionTimer() {
            if (AppState.session.active && AppState.session.startTime) {
                const elapsed = Math.floor((Date.now() - AppState.session.startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('sessionTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
        }
        
        function toggleVoice() {
            if (AppState.isListening) {
                voiceEngine.stopListening();
            } else {
                voiceEngine.startListening();
            }
        }
        
        async function toggleHandsFreeMode() {
            if (voiceEngine.handsFreeMode) {
                voiceEngine.stopHandsFreeMode();
                
                // Update desktop status
                const desktopStatus = document.getElementById('handsFreeStatus');
                if (desktopStatus) desktopStatus.style.display = 'none';
                
                // Update mobile status bar
                const mobileStatus = document.getElementById('handsFreeStatusMobile');
                if (mobileStatus) mobileStatus.classList.remove('active');
                
                // Update desktop button
                const desktopBtn = document.getElementById('handsFreeBtn');
                if (desktopBtn) {
                    desktopBtn.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
                    desktopBtn.innerHTML = '<span>üéôÔ∏è</span> Hands-Free';
                }
                
                // Update mobile FAB
                const fab = document.getElementById('fabHandsFree');
                if (fab) {
                    fab.classList.remove('listening');
                    fab.innerHTML = 'üéôÔ∏è';
                }
                
                showToast('Hands-free mode disabled', 'info');
            } else {
                if (!AppState.session.active) {
                    showToast('Start a session first!', 'error');
                    return;
                }
                const useWakeWord = document.getElementById('wakeWordEnabled')?.checked || false;
                voiceEngine.startHandsFreeMode(useWakeWord);
                
                // Update desktop status
                const desktopStatus = document.getElementById('handsFreeStatus');
                if (desktopStatus) desktopStatus.style.display = 'block';
                
                // Update mobile status bar
                const mobileStatus = document.getElementById('handsFreeStatusMobile');
                const statusText = document.getElementById('handsFreeStatusText');
                if (mobileStatus) {
                    mobileStatus.classList.add('active');
                    if (statusText) {
                        statusText.textContent = useWakeWord 
                            ? 'Say "Hey VoiceCards" before commands'
                            : 'Say: "Easy", "Good", "Hard", "Repeat", "Show", or "Stop"';
                    }
                }
                
                // Update desktop button
                const desktopBtn = document.getElementById('handsFreeBtn');
                if (desktopBtn) {
                    desktopBtn.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
                    desktopBtn.innerHTML = '<span>üõë</span> Stop Hands-Free';
                }
                
                // Update mobile FAB
                const fab = document.getElementById('fabHandsFree');
                if (fab) {
                    fab.classList.add('listening');
                    fab.innerHTML = 'üõë';
                }
                
                // Update desktop status text
                const desktopStatusText = useWakeWord 
                    ? 'üéôÔ∏è Hands-Free Mode (Wake Word) - Say "Hey VoiceCards" before commands'
                    : 'üéôÔ∏è Hands-Free Mode Active - Say: "Easy", "Good", "Hard", "Repeat", "Show", or "Stop"';
                const desktopStatusDiv = document.querySelector('#handsFreeStatus > div:first-child');
                const desktopStatusSub = document.querySelector('#handsFreeStatus > div:last-child');
                if (desktopStatusDiv) desktopStatusDiv.textContent = desktopStatusText.split(' - ')[0];
                if (desktopStatusSub) desktopStatusSub.textContent = desktopStatusText.split(' - ')[1] || '';
            }
        }
        
        // Onboarding Functions
        function selectFeature(element) {
            element.classList.toggle('selected');
        }
        
        function nextOnboardingStep() {
            document.getElementById('step1').classList.remove('active');
            document.getElementById('step2').classList.add('active');
        }
        
        function selectDeck(deck) {
            document.querySelectorAll('.feature-card').forEach(card => {
                card.classList.remove('selected');
            });
            event.target.closest('.feature-card').classList.add('selected');
            AppState.session.deck = deck;
        }
        
        async function completeOnboarding() {
            const useVoiceOnboarding = confirm('Would you like to try voice-only onboarding? Perfect for hands-free setup!');
            localStorage.setItem('hasOnboarded', 'true');
            localStorage.setItem('voiceOnboarding', useVoiceOnboarding ? 'true' : 'false');
            
            if (useVoiceOnboarding) {
                showSection('study');
                await startVoiceOnboarding();
            } else {
                showSection('study');
                showToast('Welcome to VoiceCards! Let\'s start learning!', 'success');
            }
        }
        
        // Settings Functions
        function loadSettings() {
            // Load from localStorage
            const settings = JSON.parse(localStorage.getItem('settings') || '{}');
            
            // Apply settings
            if (settings.voiceEnabled !== undefined) {
                document.getElementById('voiceEnabled').checked = settings.voiceEnabled;
            }
            if (settings.autoPronounce !== undefined) {
                document.getElementById('autoPronounce').checked = settings.autoPronounce;
            }
            if (settings.conversationalMode !== undefined) {
                document.getElementById('conversationalMode').checked = settings.conversationalMode;
            }
            if (settings.offlineMode !== undefined) {
                document.getElementById('offlineMode').checked = settings.offlineMode;
            }
            if (settings.handsFreeEnabled !== undefined) {
                document.getElementById('handsFreeEnabled').checked = settings.handsFreeEnabled;
            }
            if (settings.wakeWordEnabled !== undefined) {
                document.getElementById('wakeWordEnabled').checked = settings.wakeWordEnabled;
            }
            if (settings.backgroundAudioEnabled !== undefined) {
                document.getElementById('backgroundAudioEnabled').checked = settings.backgroundAudioEnabled;
            }
            
            // Load AI settings
            const apiKey = localStorage.getItem('aiApiKey') || '';
            const apiProvider = localStorage.getItem('aiApiProvider') || 'anthropic';
            const conversationalEnabled = localStorage.getItem('conversationalMode') === 'true';
            
            if (document.getElementById('aiApiKey')) {
                document.getElementById('aiApiKey').value = apiKey;
            }
            if (document.getElementById('aiProvider')) {
                document.getElementById('aiProvider').value = apiProvider;
            }
            if (document.getElementById('conversationalFeaturesEnabled')) {
                document.getElementById('conversationalFeaturesEnabled').checked = conversationalEnabled;
            }
            
            // Update agents
            conversationalAgent.apiKey = apiKey;
            conversationalAgent.apiProvider = apiProvider;
            conversationalAgent.enabled = conversationalEnabled;
            
            const geminiApiKey = localStorage.getItem('geminiApiKey') || '';
            const useGeminiLive = localStorage.getItem('useGeminiLiveAPI') === 'true';
            const useRealtime = localStorage.getItem('useRealtimeAPI') === 'true';
            const useGeminiTTS = localStorage.getItem('useGeminiTTS') === 'true';
            const geminiTTSVoice = localStorage.getItem('geminiTTSVoice') || 'Kore';
            
            if (document.getElementById('geminiApiKey')) {
                document.getElementById('geminiApiKey').value = geminiApiKey;
            }
            if (document.getElementById('useGeminiLiveAPI')) {
                document.getElementById('useGeminiLiveAPI').checked = useGeminiLive;
            }
            if (document.getElementById('useRealtimeAPI')) {
                document.getElementById('useRealtimeAPI').checked = useRealtime;
            }
            if (document.getElementById('useGeminiTTS')) {
                document.getElementById('useGeminiTTS').checked = useGeminiTTS;
            }
            if (document.getElementById('geminiTTSVoice')) {
                document.getElementById('geminiTTSVoice').value = geminiTTSVoice;
            }
            if (document.getElementById('geminiTTSVoiceContainer')) {
                document.getElementById('geminiTTSVoiceContainer').style.display = useGeminiTTS ? 'flex' : 'none';
            }
            
            if (typeof geminiLiveAgent !== 'undefined') {
                geminiLiveAgent.apiKey = geminiApiKey;
            }
            if (typeof geminiTTS !== 'undefined') {
                geminiTTS.apiKey = geminiApiKey;
                geminiTTS.enabled = useGeminiTTS;
                geminiTTS.voiceName = geminiTTSVoice;
            }
            if (typeof openAIRealtimeAgent !== 'undefined') {
                openAIRealtimeAgent.apiKey = apiKey; // Uses same API key as conversational agent
            }
        }
        
        function saveSettings() {
            const settings = {
                voiceEnabled: document.getElementById('voiceEnabled')?.checked,
                autoPronounce: document.getElementById('autoPronounce')?.checked,
                conversationalMode: document.getElementById('conversationalMode')?.checked,
                offlineMode: document.getElementById('offlineMode')?.checked,
                handsFreeEnabled: document.getElementById('handsFreeEnabled')?.checked,
                wakeWordEnabled: document.getElementById('wakeWordEnabled')?.checked,
                backgroundAudioEnabled: document.getElementById('backgroundAudioEnabled')?.checked
            };
            
            localStorage.setItem('settings', JSON.stringify(settings));
            showToast('Settings saved', 'success');
        }
        
        function saveAISettings() {
            const apiKey = document.getElementById('aiApiKey')?.value || '';
            const apiProvider = document.getElementById('aiProvider')?.value || 'anthropic';
            const enabled = document.getElementById('conversationalFeaturesEnabled')?.checked || false;
            const geminiApiKey = document.getElementById('geminiApiKey')?.value || '';
            const useGeminiLive = document.getElementById('useGeminiLiveAPI')?.checked || false;
            const useRealtime = document.getElementById('useRealtimeAPI')?.checked || false;
            const useGeminiTTS = document.getElementById('useGeminiTTS')?.checked || false;
            const geminiTTSVoice = document.getElementById('geminiTTSVoice')?.value || 'Kore';
            
            localStorage.setItem('aiApiKey', apiKey);
            localStorage.setItem('aiApiProvider', apiProvider);
            localStorage.setItem('conversationalMode', enabled.toString());
            localStorage.setItem('geminiApiKey', geminiApiKey);
            localStorage.setItem('useGeminiLiveAPI', useGeminiLive.toString());
            localStorage.setItem('useRealtimeAPI', useRealtime.toString());
            localStorage.setItem('useGeminiTTS', useGeminiTTS.toString());
            localStorage.setItem('geminiTTSVoice', geminiTTSVoice);
            
            conversationalAgent.apiKey = apiKey;
            conversationalAgent.apiProvider = apiProvider;
            conversationalAgent.enabled = enabled;
            
            geminiLiveAgent.apiKey = geminiApiKey;
            
            if (typeof openAIRealtimeAgent !== 'undefined') {
                openAIRealtimeAgent.apiKey = apiKey; // Uses same API key as conversational agent
            }
            
            if (typeof geminiTTS !== 'undefined') {
                geminiTTS.apiKey = geminiApiKey;
                geminiTTS.enabled = useGeminiTTS;
                geminiTTS.voiceName = geminiTTSVoice;
            }
            
            // Show/hide voice selector based on TTS toggle
            const voiceContainer = document.getElementById('geminiTTSVoiceContainer');
            if (voiceContainer) {
                voiceContainer.style.display = useGeminiTTS ? 'flex' : 'none';
            }
            
            showToast('AI settings saved', 'success');
        }
        
        // Utility Functions
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <span class="toast-icon">${type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : '‚ÑπÔ∏è'}</span>
                <span class="toast-message">${message}</span>
            `;
            
            document.getElementById('toastContainer').appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'slideInRight 0.3s ease reverse';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
        
        function showModal(modalId) {
            document.getElementById(modalId).classList.add('active');
        }
        
        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }
        
        function showImportModal() {
            showModal('importModal');
        }
        
        function showCreateDeckModal() {
            document.getElementById('newDeckName').value = '';
            showModal('createDeckModal');
        }
        
        async function createNewDeck() {
            const deckName = document.getElementById('newDeckName').value.trim();
            if (!deckName) {
                showToast('Please enter a deck name', 'error');
                return;
            }
            
            if (!AppState.user.authenticated) {
                showToast('Please login to create decks', 'error');
                showLoginModal();
                return;
            }
            
            try {
                const deck = await db.saveDeck({
                    name: deckName,
                    description: '',
                    is_public: false
                });
                
                AppState.decks[deck.id] = {
                    id: deck.id,
                    name: deck.name,
                    description: deck.description || '',
                    isPublic: deck.is_public || false,
                    cards: []
                };
                
                document.getElementById('newDeckName').value = '';
                closeModal('createDeckModal');
                showToast(`Deck "${deckName}" created!`, 'success');
                await renderDecks();
            } catch (error) {
                console.error('Failed to create deck:', error);
                showToast('Failed to create deck: ' + error.message, 'error');
            }
        }
        
        async function renderDecks() {
            const decksList = document.getElementById('decksList');
            if (!decksList) return;
            
            decksList.innerHTML = '';
            
            // Show login prompt if not authenticated
            if (!AppState.user.authenticated) {
                decksList.innerHTML = `
                    <div class="feature-card" style="text-align: center; padding: 40px;">
                        <h3 style="margin-bottom: 15px;">Please login to access your decks</h3>
                        <button class="control-btn btn-primary" onclick="showLoginModal()">Login / Register</button>
                    </div>
                `;
                return;
            }
            
            // Load decks if empty
            if (Object.keys(AppState.decks).length === 0) {
                await loadUserData();
            }
            
            for (const [deckId, deck] of Object.entries(AppState.decks)) {
                // Load cards for this deck
                if (!deck.cards || deck.cards.length === 0) {
                    try {
                        deck.cards = await db.getCards(deckId);
                    } catch (error) {
                        console.error('Failed to load cards:', error);
                        deck.cards = [];
                    }
                }
                
                const now = new Date();
                const dueCount = deck.cards.filter(card => {
                    if (!card.nextReview) return true;
                    return new Date(card.nextReview) <= now;
                }).length;
                
                const deckCard = document.createElement('div');
                deckCard.className = 'feature-card';
                deckCard.style.cursor = 'pointer';
                deckCard.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 15px;">
                        <div>
                            <h3 style="margin: 0; font-size: 20px;">${deck.name}</h3>
                            ${deck.description ? `<p style="color: var(--gray); font-size: 14px; margin: 5px 0 0 0;">${deck.description}</p>` : ''}
                        </div>
                        <span style="background: var(--primary); color: white; padding: 4px 12px; border-radius: 12px; font-size: 12px;">${deck.cards.length} cards</span>
                    </div>
                    <div style="color: var(--gray); font-size: 14px; margin-bottom: 15px;">
                        ${dueCount} cards due for review
                    </div>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="control-btn btn-primary" style="flex: 1; padding: 8px;" onclick="startSession('${deckId}')">
                            Study
                        </button>
                        <button class="control-btn btn-secondary" style="flex: 1; padding: 8px;" onclick="editDeck('${deckId}')">
                            Edit
                        </button>
                        <button class="control-btn btn-secondary" style="padding: 8px;" onclick="exportDeck('${deckId}')" title="Export">
                            üì§
                        </button>
                    </div>
                `;
                decksList.appendChild(deckCard);
            }
            
            // Show empty state
            if (Object.keys(AppState.decks).length === 0) {
                decksList.innerHTML = `
                    <div class="feature-card" style="text-align: center; padding: 40px;">
                        <h3 style="margin-bottom: 15px;">No decks yet</h3>
                        <p style="color: var(--gray); margin-bottom: 20px;">Create your first deck to get started!</p>
                        <button class="control-btn btn-primary" onclick="showModal('createDeckModal')">Create Deck</button>
                    </div>
                `;
            }
        }
        
        function editDeck(deckName) {
            AppState.editingDeck = deckName;
            showSection('study'); // We'll add a deck editor view
            showToast(`Editing ${deckName} deck - Click cards to edit`, 'info');
            // For now, show cards in a list
            renderDeckEditor(deckName);
        }
        
        function renderDeckEditor(deckName) {
            const mainContent = document.querySelector('.main-content');
            if (!mainContent) return;
            
            const cards = AppState.decks[deckName] || [];
            
            mainContent.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <button class="control-btn btn-secondary" onclick="showSection('decks')" style="padding: 8px 15px;">
                            ‚Üê Back
                        </button>
                        <h2 style="margin: 0;">Edit Deck: ${deckName}</h2>
                    </div>
                    <button class="control-btn btn-primary" onclick="addNewCard('${deckName}')">
                        <span>‚ûï</span> Add Card
                    </button>
                </div>
                <div id="cardsList" style="display: grid; gap: 15px;">
                    ${cards.length === 0 ? '<p style="text-align: center; color: var(--gray); padding: 40px;">No cards yet. Click "Add Card" to get started!</p>' : cards.map(card => `
                        <div class="feature-card" onclick="editCard(${card.id}, '${deckName}')" style="cursor: pointer;">
                            <div style="font-weight: 600; margin-bottom: 8px;">${card.front}</div>
                            <div style="color: var(--gray); font-size: 14px;">${card.back}</div>
                            ${card.pronunciation ? `<div style="color: var(--primary); font-size: 12px; margin-top: 5px;">${card.pronunciation}</div>` : ''}
                        </div>
                    `).join('')}
                </div>
            `;
        }
        
        function addNewCard(deckName) {
            AppState.editingCard = null;
            AppState.editingCardDeck = deckName;
            document.getElementById('cardEditorTitle').textContent = 'Add New Card';
            document.getElementById('cardFrontInput').value = '';
            document.getElementById('cardBackInput').value = '';
            document.getElementById('cardPronInput').value = '';
            document.getElementById('deleteCardBtn').style.display = 'none';
            showModal('cardEditorModal');
        }
        
        function editCard(cardId, deckName) {
            const card = AppState.decks[deckName].find(c => c.id === cardId);
            if (!card) return;
            
            AppState.editingCard = card;
            AppState.editingCardDeck = deckName;
            document.getElementById('cardEditorTitle').textContent = 'Edit Card';
            document.getElementById('cardFrontInput').value = card.front;
            document.getElementById('cardBackInput').value = card.back;
            document.getElementById('cardPronInput').value = card.pronunciation || '';
            document.getElementById('deleteCardBtn').style.display = 'block';
            showModal('cardEditorModal');
        }
        
        async function saveCard() {
            const front = document.getElementById('cardFrontInput').value.trim();
            const back = document.getElementById('cardBackInput').value.trim();
            const pronunciation = document.getElementById('cardPronInput').value.trim();
            
            if (!front || !back) {
                showToast('Front and back are required', 'error');
                return;
            }
            
            const deckId = AppState.editingCardDeck;
            
            if (!deckId) {
                showToast('No deck selected', 'error');
                return;
            }
            
            try {
                if (AppState.editingCard) {
                    // Update existing card
                    const updatedCard = await db.saveCard({
                        id: AppState.editingCard.id,
                        front,
                        back,
                        pronunciation,
                        deck_id: deckId
                    });
                    
                    // Update local state
                    const deck = AppState.decks[deckId];
                    if (deck && deck.cards) {
                        const index = deck.cards.findIndex(c => c.id === updatedCard.id);
                        if (index >= 0) {
                            deck.cards[index] = updatedCard;
                        }
                    }
                    
                    showToast('Card updated!', 'success');
                } else {
                    // Create new card
                    const newCard = await db.saveCard({
                        front,
                        back,
                        pronunciation,
                        deck_id: deckId
                    });
                    
                    // Add to local state
                    if (!AppState.decks[deckId]) {
                        AppState.decks[deckId] = { id: deckId, cards: [] };
                    }
                    if (!AppState.decks[deckId].cards) {
                        AppState.decks[deckId].cards = [];
                    }
                    AppState.decks[deckId].cards.push(newCard);
                    
                    showToast('Card created!', 'success');
                }
                
                closeModal('cardEditorModal');
                if (AppState.editingDeck === deckId) {
                    renderDeckEditor(deckId);
                }
            } catch (error) {
                console.error('Failed to save card:', error);
                showToast('Failed to save card: ' + error.message, 'error');
            }
        }
        
        async function deleteCurrentCard() {
            if (!AppState.editingCard || !AppState.editingCard.id) {
                showToast('No card selected', 'error');
                return;
            }
            
            if (!confirm('Are you sure you want to delete this card?')) {
                return;
            }
            
            try {
                await db.deleteCard(AppState.editingCard.id);
                
                // Remove from local state
                const deckId = AppState.editingCardDeck;
                if (AppState.decks[deckId] && AppState.decks[deckId].cards) {
                    AppState.decks[deckId].cards = AppState.decks[deckId].cards.filter(
                        c => c.id !== AppState.editingCard.id
                    );
                }
                
                closeModal('cardEditorModal');
                if (AppState.editingDeck === deckId) {
                    renderDeckEditor(deckId);
                }
                showToast('Card deleted', 'success');
            } catch (error) {
                console.error('Failed to delete card:', error);
                showToast('Failed to delete card: ' + error.message, 'error');
            }
        }
        
        function editDeck(deckId) {
            AppState.editingDeck = deckId;
            showSection('study');
            const deck = AppState.decks[deckId];
            showToast(`Editing ${deck?.name || 'deck'} - Click cards to edit`, 'info');
            renderDeckEditor(deckId);
        }
        
        async function renderDeckEditor(deckId) {
            const mainContent = document.querySelector('.main-content');
            if (!mainContent) return;
            
            const deck = AppState.decks[deckId];
            if (!deck) {
                mainContent.innerHTML = '<p>Deck not found</p>';
                return;
            }
            
            // Load cards if not loaded
            if (!deck.cards || deck.cards.length === 0) {
                try {
                    deck.cards = await db.getCards(deckId);
                } catch (error) {
                    console.error('Failed to load cards:', error);
                    deck.cards = [];
                }
            }
            
            const cards = deck.cards || [];
            
            mainContent.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <button class="control-btn btn-secondary" onclick="showSection('decks')" style="padding: 8px 15px;">
                            ‚Üê Back
                        </button>
                        <h2 style="margin: 0;">Edit Deck: ${deck.name}</h2>
                    </div>
                    <button class="control-btn btn-primary" onclick="addNewCard('${deckId}')">
                        <span>‚ûï</span> Add Card
                    </button>
                </div>
                <div id="cardsList" style="display: grid; gap: 15px;">
                    ${cards.length === 0 ? '<p style="text-align: center; color: var(--gray); padding: 40px;">No cards yet. Click "Add Card" to get started!</p>' : cards.map(card => `
                        <div class="feature-card" onclick="editCard('${card.id}', '${deckId}')" style="cursor: pointer;">
                            <div style="font-weight: 600; margin-bottom: 8px;">${card.front}</div>
                            <div style="color: var(--gray); font-size: 14px;">${card.back}</div>
                            ${card.pronunciation ? `<div style="color: var(--primary); font-size: 12px; margin-top: 5px;">${card.pronunciation}</div>` : ''}
                        </div>
                    `).join('')}
                </div>
            `;
        }
        
        function addNewCard(deckId) {
            AppState.editingCard = null;
            AppState.editingCardDeck = deckId;
            document.getElementById('cardEditorTitle').textContent = 'Add New Card';
            document.getElementById('cardFrontInput').value = '';
            document.getElementById('cardBackInput').value = '';
            document.getElementById('cardPronInput').value = '';
            document.getElementById('deleteCardBtn').style.display = 'none';
            showModal('cardEditorModal');
        }
        
        function editCard(cardId, deckId) {
            const deck = AppState.decks[deckId];
            if (!deck || !deck.cards) return;
            
            const card = deck.cards.find(c => c.id === cardId || c.id === cardId.toString());
            if (!card) return;
            
            AppState.editingCard = card;
            AppState.editingCardDeck = deckId;
            document.getElementById('cardEditorTitle').textContent = 'Edit Card';
            document.getElementById('cardFrontInput').value = card.front;
            document.getElementById('cardBackInput').value = card.back;
            document.getElementById('cardPronInput').value = card.pronunciation || '';
            document.getElementById('deleteCardBtn').style.display = 'block';
            showModal('cardEditorModal');
        }
                };
                
                if (!AppState.decks[deckName]) {
                    AppState.decks[deckName] = [];
                }
                AppState.decks[deckName].push(newCard);
                await db.saveCard(newCard);
                showToast('Card added!', 'success');
            }
            
            closeModal('cardEditorModal');
            renderDeckEditor(deckName);
        }
        
        async function deleteCurrentCard() {
            if (!AppState.editingCard) return;
            
            if (confirm('Are you sure you want to delete this card?')) {
                const deckName = AppState.editingCardDeck;
                AppState.decks[deckName] = AppState.decks[deckName].filter(c => c.id !== AppState.editingCard.id);
                await db.deleteCard(AppState.editingCard.id);
                closeModal('cardEditorModal');
                renderDeckEditor(deckName);
                showToast('Card deleted', 'success');
            }
        }
        
        function exportDeck(deckName) {
            const cards = AppState.decks[deckName] || [];
            const exportData = cards.map(card => ({
                front: card.front,
                back: card.back,
                pronunciation: card.pronunciation || '',
                deck: card.deck
            }));
            
            const jsonStr = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${deckName}-deck.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showToast('Deck exported!', 'success');
        }
        
        async function handleCSVImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const text = await file.text();
            const lines = text.split('\n').filter(line => line.trim());
            const headers = lines[0].split(',').map(h => h.trim());
            
            const deckName = file.name.replace('.csv', '').toLowerCase().replace(/\s+/g, '-');
            if (!AppState.decks[deckName]) {
                AppState.decks[deckName] = [];
            }
            
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',').map(v => v.trim());
                const card = {
                    id: Date.now() + i,
                    front: values[0] || '',
                    back: values[1] || '',
                    pronunciation: values[2] || '',
                    deck: deckName,
                    nextReview: null,
                    repetitions: 0,
                    easeFactor: 2.5,
                    interval: 1
                };
                
                AppState.decks[deckName].push(card);
                await db.saveCard(card);
            }
            
            closeModal('importModal');
            showToast(`Imported ${lines.length - 1} cards from CSV!`, 'success');
            renderDecks();
            updateDeckCounts();
        }
        
        async function handleJSONImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const text = await file.text();
            await importJSONCards(text);
        }
        
        async function handleJSONPaste() {
            const text = document.getElementById('jsonPasteInput').value.trim();
            if (!text) {
                showToast('Please paste JSON data', 'error');
                return;
            }
            
            await importJSONCards(text);
        }
        
        async function importJSONCards(jsonText) {
            try {
                const cards = JSON.parse(jsonText);
                if (!Array.isArray(cards)) {
                    showToast('JSON must be an array of cards', 'error');
                    return;
                }
                
                const deckNames = new Set();
                for (const cardData of cards) {
                    const deckName = (cardData.deck || 'imported').toLowerCase().replace(/\s+/g, '-');
                    deckNames.add(deckName);
                    
                    if (!AppState.decks[deckName]) {
                        AppState.decks[deckName] = [];
                    }
                    
                    const card = {
                        id: cardData.id || Date.now() + Math.random(),
                        front: cardData.front,
                        back: cardData.back,
                        pronunciation: cardData.pronunciation || '',
                        deck: deckName,
                        nextReview: cardData.nextReview ? new Date(cardData.nextReview) : null,
                        repetitions: cardData.repetitions || 0,
                        easeFactor: cardData.easeFactor || 2.5,
                        interval: cardData.interval || 1
                    };
                    
                    AppState.decks[deckName].push(card);
                    await db.saveCard(card);
                }
                
                closeModal('importModal');
                showToast(`Imported ${cards.length} cards into ${deckNames.size} deck(s)!`, 'success');
                renderDecks();
                updateDeckCounts();
            } catch (error) {
                showToast('Invalid JSON format: ' + error.message, 'error');
            }
        }
        
        function updateOnlineStatus() {
            const online = navigator.onLine;
            const syncIcon = document.getElementById('syncIcon');
            const syncText = document.getElementById('syncText');
            const offlineBanner = document.getElementById('offlineBanner');
            
            if (online) {
                syncIcon.textContent = '‚òÅÔ∏è';
                syncText.textContent = 'Synced';
                offlineBanner.classList.remove('active');
                AppState.syncStatus = 'synced';
                
                // Sync any offline changes
                syncOfflineData();
            } else {
                syncIcon.textContent = 'üìµ';
                syncText.textContent = 'Offline';
                offlineBanner.classList.add('active');
                AppState.syncStatus = 'offline';
            }
        }
        
        async function syncOfflineData() {
            // In a real app, this would sync with Supabase
            showToast('Syncing offline changes...', 'info');
            
            // Simulate sync
            setTimeout(() => {
                showToast('All changes synced!', 'success');
            }, 2000);
        }
        
        // Keyboard Shortcuts
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Don't trigger shortcuts when typing in inputs
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
                    return;
                }
                
                // Space or Enter: Flip card
                if ((e.key === ' ' || e.key === 'Enter') && AppState.session.active) {
                    e.preventDefault();
                    const cardInner = document.getElementById('cardInner');
                    if (!cardInner.classList.contains('flipped')) {
                        showCard();
                    }
                }
                
                // Number keys 1-5: Rate card difficulty
                if (e.key >= '1' && e.key <= '5' && AppState.session.active) {
                    e.preventDefault();
                    const quality = parseInt(e.key);
                    rateCard(quality);
                }
                
                // V: Toggle voice
                if (e.key === 'v' || e.key === 'V') {
                    e.preventDefault();
                    if (AppState.session.active) {
                        toggleVoice();
                    }
                }
                
                // Arrow keys: Navigate sections (when not in session)
                if (!AppState.session.active) {
                    if (e.key === 'ArrowLeft') {
                        e.preventDefault();
                        const sections = ['study', 'decks', 'analytics', 'settings'];
                        const current = document.querySelector('.app-container.active')?.id;
                        const currentIndex = sections.indexOf(current);
                        if (currentIndex > 0) {
                            showSection(sections[currentIndex - 1]);
                        }
                    }
                    if (e.key === 'ArrowRight') {
                        e.preventDefault();
                        const sections = ['study', 'decks', 'analytics', 'settings'];
                        const current = document.querySelector('.app-container.active')?.id;
                        const currentIndex = sections.indexOf(current);
                        if (currentIndex < sections.length - 1) {
                            showSection(sections[currentIndex + 1]);
                        }
                    }
                }
            });
        }
        
        // Add event listeners for settings
        function setupApp() {
            // Settings change listeners (defer until DOM is ready)
            setTimeout(() => {
                document.querySelectorAll('#settings input').forEach(input => {
                    input.addEventListener('change', saveSettings);
                });
            }, 100);
            
            // Setup keyboard shortcuts
            setupKeyboardShortcuts();
            
            // Initialize app immediately
            initializeApp();
        }
        
        // Initialize immediately if DOM is ready, otherwise wait
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupApp);
        } else {
            // DOM is already ready
            setupApp();
        }
        
        // Service Worker Registration for PWA (only for http/https, not file://)
        if ('serviceWorker' in navigator && (window.location.protocol === 'http:' || window.location.protocol === 'https:')) {
            // Use relative path for service worker
            const swPath = window.location.pathname.includes('voice-flashcard-prototype.html') 
                ? './sw.js' 
                : '/sw.js';
            navigator.serviceWorker.register(swPath).then(registration => {
                console.log('ServiceWorker registered:', registration);
            }).catch(error => {
                // Silently fail - service workers don't work with file:// protocol
                console.log('ServiceWorker registration failed (expected for file:// protocol):', error.message);
            });
        }
    </script>
    
    <!-- Bottom Navigation (Mobile) -->
    <div class="bottom-nav">
        <div class="bottom-nav-item active" onclick="showSection('study')">
            <span>üìö</span>
            <span>Study</span>
        </div>
        <div class="bottom-nav-item" onclick="showSection('decks')">
            <span>üì¶</span>
            <span>Decks</span>
        </div>
        <div class="bottom-nav-item" onclick="showSection('analytics')">
            <span>üìä</span>
            <span>Stats</span>
        </div>
        <div class="bottom-nav-item" onclick="showSection('settings')">
            <span>‚öôÔ∏è</span>
            <span>Settings</span>
        </div>
    </div>
    
    <!-- Floating Action Button (Mobile) -->
    <button class="fab" id="fabHandsFree" onclick="toggleHandsFreeMode()" title="Toggle Hands-Free Mode">
        üéôÔ∏è
    </button>
</body>
</html>